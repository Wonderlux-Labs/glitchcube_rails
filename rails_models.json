{
  "directory_name": "models",
  "files": [
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/conversation_log.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/conversation_memory.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/validated_tool_call.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/ha_sync_reference.md",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/cube_persona.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/ha_data_sync.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/summary.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/message.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/mobius_persona.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/jax_persona.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/sparkle_persona.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/zorp_persona.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/lomi_persona.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/neon_persona.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/thecube_persona.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/buddy_persona.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/crash_persona.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/conversation_response.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/street.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/conversation.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/fact.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/person.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/glitch_cube.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/application_record.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/landmark.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/event.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/concerns/ai_structured_response.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/boundary.rb"
  ],
  "model_info": "ChatGPT models, text-embedding-ada-002",
  "prompt": "Project Path: models\n\nSource Tree:\n\n```\nmodels\n‚îú‚îÄ‚îÄ conversation_log.rb\n‚îú‚îÄ‚îÄ conversation_memory.rb\n‚îú‚îÄ‚îÄ validated_tool_call.rb\n‚îú‚îÄ‚îÄ ha_sync_reference.md\n‚îú‚îÄ‚îÄ cube_persona.rb\n‚îú‚îÄ‚îÄ ha_data_sync.rb\n‚îú‚îÄ‚îÄ summary.rb\n‚îú‚îÄ‚îÄ message.rb\n‚îú‚îÄ‚îÄ personas\n‚îÇ   ‚îú‚îÄ‚îÄ mobius_persona.rb\n‚îÇ   ‚îú‚îÄ‚îÄ jax_persona.rb\n‚îÇ   ‚îú‚îÄ‚îÄ sparkle_persona.rb\n‚îÇ   ‚îú‚îÄ‚îÄ zorp_persona.rb\n‚îÇ   ‚îú‚îÄ‚îÄ lomi_persona.rb\n‚îÇ   ‚îú‚îÄ‚îÄ neon_persona.rb\n‚îÇ   ‚îú‚îÄ‚îÄ thecube_persona.rb\n‚îÇ   ‚îú‚îÄ‚îÄ buddy_persona.rb\n‚îÇ   ‚îî‚îÄ‚îÄ crash_persona.rb\n‚îú‚îÄ‚îÄ conversation_response.rb\n‚îú‚îÄ‚îÄ street.rb\n‚îú‚îÄ‚îÄ conversation.rb\n‚îú‚îÄ‚îÄ fact.rb\n‚îú‚îÄ‚îÄ person.rb\n‚îú‚îÄ‚îÄ glitch_cube.rb\n‚îú‚îÄ‚îÄ application_record.rb\n‚îú‚îÄ‚îÄ landmark.rb\n‚îú‚îÄ‚îÄ event.rb\n‚îú‚îÄ‚îÄ concerns\n‚îÇ   ‚îî‚îÄ‚îÄ ai_structured_response.rb\n‚îî‚îÄ‚îÄ boundary.rb\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/conversation_log.rb`:\n\n```rb\nclass ConversationLog < ApplicationRecord\n  belongs_to :conversation, foreign_key: :session_id, primary_key: :session_id\n\n  validates :session_id, presence: true\n  validates :user_message, presence: true\n  validates :ai_response, presence: true\n\n  scope :by_session, ->(session_id) { where(session_id: session_id) }\n  scope :recent, -> { order(created_at: :desc) }\n  scope :chronological, -> { order(created_at: :asc) }\n\n  # Automatically sync narrative data to Home Assistant after each conversation\n  after_commit :sync_narrative_data_to_ha, on: [ :create, :update ]\n\n  def tool_results_json\n    return {} if tool_results.blank?\n    JSON.parse(tool_results)\n  rescue JSON::ParserError\n    {}\n  end\n\n  def metadata_json\n    return {} if metadata.blank?\n    JSON.parse(metadata)\n  rescue JSON::ParserError\n    {}\n  end\n\n  def tool_results_json=(hash)\n    self.tool_results = hash.to_json\n  end\n\n  def metadata_json=(hash)\n    self.metadata = hash.to_json\n  end\n\n  private\n\n  def sync_narrative_data_to_ha\n    # Perform HA sync in background to avoid blocking the main thread\n    WorldStateUpdaters::NarrativeConversationSyncJob.perform_later(id)\n  rescue StandardError => e\n    Rails.logger.error \"Failed to queue narrative sync job for conversation_log #{id}: #{e.message}\"\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/conversation_memory.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass ConversationMemory < ApplicationRecord\n  vectorsearch\n\n  after_save :upsert_to_vectorsearch\n\n  belongs_to :conversation, foreign_key: :session_id, primary_key: :session_id\n\n  MEMORY_TYPES = %w[preference fact instruction context event].freeze\n  IMPORTANCE_RANGE = (1..10).freeze\n\n  validates :session_id, presence: true\n  validates :summary, presence: true\n  validates :memory_type, presence: true, inclusion: { in: MEMORY_TYPES }\n  validates :importance, presence: true, inclusion: { in: IMPORTANCE_RANGE }\n\n  scope :by_session, ->(session_id) { where(session_id: session_id) }\n  scope :by_type, ->(type) { where(memory_type: type) }\n  scope :by_importance, ->(importance) { where(importance: importance) }\n  scope :high_importance, -> { where(importance: 7..10) }\n  scope :medium_importance, -> { where(importance: 4..6) }\n  scope :low_importance, -> { where(importance: 1..3) }\n  scope :recent, -> { order(created_at: :desc) }\n\n  # Dynamic scopes for all memory types\n  MEMORY_TYPES.each do |type|\n    scope type.to_sym, -> { where(memory_type: type) }\n  end\n\n  def metadata_json\n    return {} if metadata.blank?\n    JSON.parse(metadata)\n  rescue JSON::ParserError\n    {}\n  end\n\n  def metadata_json=(hash)\n    self.metadata = hash.to_json\n  end\n\n  def high_importance?\n    importance >= 7\n  end\n\n  def medium_importance?\n    importance.between?(4, 6)\n  end\n\n  def low_importance?\n    importance <= 3\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/validated_tool_call.rb`:\n\n```rb\n# frozen_string_literal: true\n\n# Wrapper around OpenRouter::ToolCall that adds validation capabilities\n# This bridges the gap between OpenRouter's basic ToolCall and our needs for:\n# - Parameter validation with helpful error messages\n# - Integration with tool definitions' validation blocks\n# - Enhanced error reporting for better UX\nclass ValidatedToolCall\n  # Delegate core OpenRouter::ToolCall functionality\n  delegate :id, :name, :arguments, :to_result_message, :to_h, :to_json, to: :@tool_call\n\n  attr_reader :tool_call, :tool_definition\n\n  def initialize(tool_call, tool_definition = nil)\n    unless tool_call.is_a?(OpenRouter::ToolCall)\n      raise ArgumentError, \"Expected OpenRouter::ToolCall, got #{tool_call.class}\"\n    end\n\n    @tool_call = tool_call\n    @tool_definition = tool_definition\n    @validation_errors = nil # Cache validation results\n  end\n\n  # Check if the tool call is valid according to its definition\n  def valid?\n    validation_errors.empty?\n  end\n\n  # Get detailed validation error messages\n  def validation_errors\n    return @validation_errors if @validation_errors\n\n    @validation_errors = []\n\n    # If no tool definition provided, we can only do basic checks\n    if @tool_definition.nil?\n      Rails.logger.warn \"No tool definition provided for validation of #{name}\"\n      return @validation_errors\n    end\n\n    # Run custom validation blocks from the tool definition\n    run_custom_validations\n\n    @validation_errors\n  end\n\n  # Reset validation state (useful for testing)\n  def reset_validation!\n    @validation_errors = nil\n  end\n\n  # Get function name (alias for consistency with OpenRouter)\n  def function_name\n    @tool_call.function_name\n  end\n\n  # Create a ValidatedToolCall from tool call data\n  def self.from_tool_call_data(tool_call_data, tool_definition = nil)\n    tool_call = OpenRouter::ToolCall.new(tool_call_data)\n    new(tool_call, tool_definition)\n  end\n\n  # Check if this tool call represents the same call as another\n  def same_call_as?(other)\n    return false unless other.is_a?(ValidatedToolCall)\n\n    id == other.id && name == other.name && arguments == other.arguments\n  end\n\n  private\n\n  def run_custom_validations\n    return unless @tool_definition.respond_to?(:validation_blocks)\n\n    @tool_definition.validation_blocks.each do |validation_block|\n      begin\n        # Pass arguments and error collection array to validation block\n        validation_result = validation_block.call(arguments, @validation_errors)\n\n        # If validation block returns an array, merge it with our errors\n        if validation_result.is_a?(Array)\n          @validation_errors.concat(validation_result)\n        end\n      rescue StandardError => e\n        Rails.logger.error \"Validation block failed for #{name}: #{e.message}\"\n        @validation_errors << \"Internal validation error: #{e.message}\"\n      end\n    end\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/ha_sync_reference.md`:\n\n```md\n# HA Sync Reference\n\n## Rails ‚Üí Home Assistant Data Sync\n\n### Backend Health & Status\n- `HaDataSync.update_backend_health(status, startup_time)` \n  - ‚Üí `input_text.backend_health_status`\n  - Template sensor: `sensor.backend_health_status`\n\n- `HaDataSync.update_deployment_status(current_commit, remote_commit, update_pending)`\n  - ‚Üí `sensor.glitchcube_deployment_status`\n\n### Conversation & Memory System\n- `HaDataSync.update_conversation_status(session_id, status, message_count, tools_used)`\n  - ‚Üí `sensor.glitchcube_conversation_status`\n\n- `HaDataSync.update_memory_stats(total_memories, recent_extractions, last_extraction_time)`\n  - ‚Üí `sensor.glitchcube_memory_stats`\n\n### World State & Context\n- `HaDataSync.update_world_state(weather_conditions, location_summary, upcoming_events)`\n  - ‚Üí `sensor.world_state`\n\n- `HaDataSync.update_glitchcube_context(time_of_day, location, weather_summary, current_needs)`\n  - ‚Üí `sensor.glitchcube_context`\n\n### Goals & Persona Management\n- `HaDataSync.update_current_goal(goal_text, importance, deadline, progress)`\n  - ‚Üí `sensor.glitchcube_current_goal`\n\n- `HaDataSync.update_persona(persona_name, capabilities, restrictions)`\n  - ‚Üí `input_select.current_persona` + `sensor.persona_details`\n\n### GPS & Location\n- `HaDataSync.update_location(lat, lng, location_name, accuracy)`\n  - ‚Üí `sensor.glitchcube_location`\n\n- `HaDataSync.update_proximity(nearby_landmarks, distance_to_landmarks)`\n  - ‚Üí `sensor.glitchcube_proximity`\n\n### Tool & Action Tracking\n- `HaDataSync.update_last_tool_execution(tool_name, success, execution_time, parameters)`\n  - ‚Üí `sensor.glitchcube_last_tool`\n\n### Health & Monitoring\n- `HaDataSync.update_api_health(endpoint, response_time, status_code, last_success)`\n  - ‚Üí `sensor.glitchcube_api_health`\n\n### Breaking News Management\n- `HaDataSync.update_breaking_news(message, expires_at)`\n  - ‚Üí `input_text.glitchcube_breaking_news`\n  - Template sensor: `sensor.glitchcube_breaking_news`\n\n- `HaDataSync.get_breaking_news()`\n  - ‚Üê `input_text.glitchcube_breaking_news`\n\n- `HaDataSync.clear_breaking_news()`\n  - ‚Üí `input_text.glitchcube_breaking_news` = \"[]\"\n\n### Summary Stats\n- `HaDataSync.update_summary_stats(total_summaries, people_extracted, events_extracted)`\n  - ‚Üí `sensor.glitchcube_summary_stats`\n\n### Mode Management\n- `HaDataSync.update_cube_mode(mode, trigger_source)`\n  - ‚Üí `input_select.cube_mode`\n  - ‚Üí `sensor.cube_mode_info` (with metadata)\n\n- `HaDataSync.get_current_mode()`\n  - ‚Üê `input_select.cube_mode`\n\n- `HaDataSync.low_power_mode?()`\n  - Returns true if current mode is \"low_power\"\n\n- `HaDataSync.enter_low_power_mode(trigger_source)`\n  - ‚Üí `input_select.cube_mode` = \"low_power\"\n\n- `HaDataSync.exit_low_power_mode(trigger_source)`\n  - ‚Üí `input_select.cube_mode` = \"conversation\"\n\n## Home Assistant ‚Üí Rails Data Sources\n\n### Memory Queries (REST sensors)\n- `sensor.recent_summaries_by_type` \n  - ‚Üê `GET /api/v1/summaries/recent?limit=3`\n\n- `sensor.memory_query_results`\n  - ‚Üê `GET /api/v1/memories/search?q=<query>&limit=<limit>`\n  - Query from: `input_text.memory_query`\n  - Limit from: `input_number.memory_query_limit`\n\n- `sensor.recent_memories`\n  - ‚Üê `GET /api/v1/memories/recent?limit=<limit>`\n  - Limit from: `input_number.recent_memories_limit`\n\n## Config Entities\n\n### Input Text\n- `input_text.memory_query` - \"burning man\"\n- `input_text.current_location` - \"Black Rock City\" \n- `input_text.glitchcube_host` - \"192.168.0.56\"\n- `input_text.backend_health_status` - Rails managed\n- `input_text.glitchcube_breaking_news` - Rails managed\n\n### Input Boolean\n- `input_boolean.low_battery` - System battery status\n- `input_boolean.low_battery_mode` - Battery automation target\n- `input_boolean.cube_busy` - System busy indicator\n- `input_boolean.motion_detected` - Motion sensor\n- `input_boolean.debug_mode` - Debug toggle\n\n### Input Select\n- `input_select.current_persona` - buddy|jax|zorp|thecube|neon|sparkle|crash|mobius\n- `input_select.cube_mode` - conversation|jukebox|performance|guide|party|ambient\n\n### Input Number\n- `input_number.memory_query_limit` - Default: 10\n- `input_number.recent_memories_limit` - Default: 10\n\n### Counters\n- `counter.daily_conversations` - Rails increments\n- `counter.total_interactions` - Rails increments\n\n## Physical Device Entities (Currently Offline)\n\n### GPS Tracker (`heltec_htit_tracker_*`)\n- 15 entities: lat/lng, speed, course, altitude, satellites, etc.\n\n### Voice Box (`esp32_s3_box_3_52b3dc_*`) \n- 15 entities: wake word, presence, temp, humidity, battery, etc.\n\n### Camera (`camera_*`)\n- 8 entities: recording, privacy, motion detection, etc.\n\n### Other Hardware\n- `siren.small_siren` - Physical siren\n- Various switches: fan, strobe, blacklight, etc.\n- Lights: cube_light_top, cube_voice_ring, etc.\n\n## Working Automations\n\n### Voice System\n- `automation.cube_voice_scene_creator_2` - Save light state on voice start\n- `automation.cube_voice_listening_2` - Green lights during listening  \n- `automation.cube_voice_processing_2` - Blue lights during processing\n- `automation.cube_voice_speaking` - Voice ring effects\n- `automation.cube_voice_speaking_and_restore` - Restore lights after\n\n### Persona Management\n- `automation.persona_switcher` - Update voice assistant settings\n- `automation.cycle_persona_button` - GLITCH theme on persona change\n- `automation.persona_change_flash` - Flash lights on persona change\n\n### Auto-Off Timers\n- `automation.siren_go_back_off` - 20s\n- `automation.fan_auto_off` - 1min + cooldown\n- `automation.strobe_auto_off` - 30s  \n- `automation.blacklight_auto_off` - 30s\n\n### Health Monitoring\n- `automation.health_lights_red` - Red lights on backend down\n- `automation.health_healthy` - Green celebration on backend up\n\n### AWTRIX Display (Some disabled)\n- `automation.awtrix_now_playing` - Show music info\n- Various persona/battery/health displays\n\n## Cube Operating Modes\n\n### Mode Definitions\n- **`conversation`** - Normal chat mode (default)\n- **`jukebox`** - Music-focused, auto-switches to Jax persona\n- **`performance`** - Extended monologues and performance mode\n- **`guide`** - Location-aware tour guide for zones\n- **`party`** - High energy, effects-heavy mode\n- **`ambient`** - Minimal interaction, mood lighting\n\n### Mode Usage Examples\n\n```ruby\n# From Rails controllers/services:\nHaDataSync.update_cube_mode(\"jukebox\", \"user_request\")\n\n# From performance service:\nHaDataSync.update_cube_mode(\"performance\", \"performance_started\")\n# ... do performance ...\nHaDataSync.update_cube_mode(\"conversation\", \"performance_ended\")\n\n# Check current mode in any service:\ncurrent_mode = HaDataSync.get_current_mode()\n# or directly:\ncurrent_mode = HomeAssistantService.entity_state(\"input_select.cube_mode\")\n```\n\n### HA Automation Examples\n\n```yaml\n# From HA automations:\nservice: input_select.select_option\ndata:\n  entity_id: input_select.cube_mode\n  option: performance\n\n# Mode-based automation trigger:\ntrigger:\n  - platform: state\n    entity_id: input_select.cube_mode\n    to: \"jukebox\"\naction:\n  - service: input_select.select_option\n    data:\n      entity_id: input_select.current_persona\n      option: \"jax\"\n```\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/cube_persona.rb`:\n\n```rb\n# frozen_string_literal: true\n\n# Abstract base class for all cube personas\n# This class defines the interface that all persona implementations must follow\nclass CubePersona\n  PERSONAS = [ :thecube, :buddy, :neon, :sparkle, :zorp, :crash, :jax, :mobius ]\n  # Not an ActiveRecord model - just a plain Ruby class\n\n  def self.current_persona\n    name = Rails.cache.fetch(\"current_persona\") do\n      HomeAssistantService.entity(\"input_select.current_persona\")&.dig(\"state\") || :buddy\n    end\n    name.to_sym\n  end\n\n  def self.set_current_persona(persona)\n    return unless PERSONAS.include? persona&.to_sym\n\n    # Get current persona before switching\n    previous_persona = current_persona\n\n    HomeAssistantService.call_service(\"input_select\", \"select_option\", entity_id: \"input_select.current_persona\", option: persona.to_s)\n    Rails.cache.write(\"current_persona\", persona.to_s, expires_in: 10.minutes)\n\n    # Handle persona switching with goal awareness\n    if previous_persona != persona.to_sym\n      PersonaSwitchService.handle_persona_switch(persona.to_sym, previous_persona)\n    end\n  end\n\n  # Abstract method: Returns the persona's unique identifier\n  # Must be implemented by subclasses\n  def persona_id\n    raise NotImplementedError, \"#{self.class} must implement persona_id\"\n  end\n\n  # Abstract method: Returns the persona's display name\n  # Must be implemented by subclasses\n  def name\n    raise NotImplementedError, \"#{self.class} must implement name\"\n  end\n\n  # Abstract method: Processes a message and returns a response\n  # @param message [String] The input message to process\n  # @param context [Hash] Additional context for processing\n  # @return [String] The persona's response\n  def process_message(message, context = {})\n    raise NotImplementedError, \"#{self.class} must implement process_message\"\n  end\n\n  # Abstract method: Returns the persona's personality traits\n  # @return [Hash] A hash containing personality configuration\n  def personality_traits\n    raise NotImplementedError, \"#{self.class} must implement personality_traits\"\n  end\n\n  # Abstract method: Returns the persona's knowledge base\n  # @return [Array<String>] Array of knowledge topics\n  def knowledge_base\n    raise NotImplementedError, \"#{self.class} must implement knowledge_base\"\n  end\n\n  # Abstract method: Returns the persona's response style\n  # @return [Hash] Configuration for response generation\n  def response_style\n    raise NotImplementedError, \"#{self.class} must implement response_style\"\n  end\n\n  # Abstract method: Returns whether the persona can handle a specific topic\n  # @param topic [String] The topic to check\n  # @return [Boolean] True if the persona can handle the topic\n  def can_handle_topic?(topic)\n    raise NotImplementedError, \"#{self.class} must implement can_handle_topic?\"\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/ha_data_sync.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass HaDataSync\n  include ActiveModel::Model\n\n  # Core System Health & Status\n  def self.update_backend_health(status, startup_time = nil)\n    # Replaces: config/application.rb:52\n    # Target: input_text.backend_health_status\n    call_ha_service(\n      \"input_text\",\n      \"set_value\",\n      \"input_text.backend_health_status\",\n      { value: \"#{status} at #{startup_time || Time.current}\" }\n    )\n    Rails.logger.info \"üè• Backend health updated: #{status}\"\n  end\n\n  def self.update_deployment_status(current_commit, remote_commit, update_pending)\n    # Future sensor: sensor.glitchcube_deployment_status\n    # Attributes: current_commit, remote_commit, needs_update\n    call_ha_service(\n      \"sensor\",\n      \"set_state\",\n      \"sensor.glitchcube_deployment_status\",\n      {\n        state: update_pending ? \"update_available\" : \"up_to_date\",\n        attributes: {\n          current_commit: current_commit,\n          remote_commit: remote_commit,\n          needs_update: update_pending\n        }\n      }\n    )\n    Rails.logger.info \"üöÄ Deployment status updated\"\n  end\n\n  # Conversation & Memory System\n  def self.update_conversation_status(session_id, status, message_count, tools_used = [])\n    # New sensor: sensor.glitchcube_conversation_status\n    # Attributes: session_id, message_count, tools_used, last_updated\n    call_ha_service(\n      \"sensor\",\n      \"set_state\",\n      \"sensor.glitchcube_conversation_status\",\n      {\n        state: status,\n        attributes: {\n          session_id: session_id,\n          message_count: message_count,\n          tools_used: tools_used,\n          last_updated: Time.current.iso8601\n        }\n      }\n    )\n    Rails.logger.info \"üí¨ Conversation status updated: #{session_id} - #{status}\"\n  end\n\n  def self.update_memory_stats(total_memories, recent_extractions, last_extraction_time)\n    # New sensor: sensor.glitchcube_memory_stats\n    # Attributes: total_count, recent_extractions, last_extraction\n    call_ha_service(\n      \"sensor\",\n      \"set_state\",\n      \"sensor.glitchcube_memory_stats\",\n      {\n        state: total_memories,\n        attributes: {\n          total_count: total_memories,\n          recent_extractions: recent_extractions,\n          last_extraction: last_extraction_time&.iso8601\n        }\n      }\n    )\n    Rails.logger.info \"üß† Memory stats updated: #{total_memories} total\"\n  end\n\n  # World State & Context (currently in world_state_updaters/)\n  def self.update_world_state(weather_conditions, location_summary, upcoming_events)\n    # Replaces: app/services/world_state_updaters/weather_forecast_summarizer_service.rb:208\n    # Target: sensor.world_state\n    call_ha_service(\n      \"sensor\",\n      \"set_state\",\n      \"sensor.world_state\",\n      {\n        state: \"active\",\n        attributes: {\n          weather_conditions: weather_conditions,\n          location_summary: location_summary,\n          upcoming_events: upcoming_events,\n          last_updated: Time.current.iso8601\n        }\n      }\n    )\n    Rails.logger.info \"üåç World state updated\"\n  end\n\n  def self.update_glitchcube_context(time_of_day, location, weather_summary, current_needs = nil)\n    # Enhances: data/homeassistant/template/glitchcube_context.yaml\n    # Target: sensor.glitchcube_context\n    call_ha_service(\n      \"sensor\",\n      \"set_state\",\n      \"sensor.glitchcube_context\",\n      {\n        state: \"active\",\n        attributes: {\n          time_of_day: time_of_day,\n          current_location: location,\n          weather_summary: weather_summary,\n          current_needs: current_needs,\n          last_updated: Time.current.iso8601\n        }\n      }\n    )\n    Rails.logger.info \"üéØ Context updated: #{time_of_day} at #{location}\"\n  end\n\n  # Goals & Persona Management\n  def self.update_current_goal(goal_text, importance, deadline = nil, progress = nil)\n    # Replaces: app/services/goal_service.rb:227,255\n    # Target: sensor.glitchcube_current_goal\n    call_ha_service(\n      \"sensor\",\n      \"set_state\",\n      \"sensor.glitchcube_current_goal\",\n      {\n        state: goal_text.truncate(50),\n        attributes: {\n          goal_text: goal_text,\n          importance: importance,\n          deadline: deadline&.iso8601,\n          progress: progress,\n          last_updated: Time.current.iso8601\n        }\n      }\n    )\n    Rails.logger.info \"üéØ Goal updated: #{goal_text.truncate(50)}\"\n  end\n\n  def self.update_persona(persona_name, capabilities = [], restrictions = [])\n    # Replaces: app/models/cube_persona.rb:22\n    # Target: input_select.current_persona + sensor.persona_details\n    call_ha_service(\n      \"input_select\",\n      \"select_option\",\n      \"input_select.current_persona\",\n      { option: persona_name }\n    )\n\n    call_ha_service(\n      \"sensor\",\n      \"set_state\",\n      \"sensor.persona_details\",\n      {\n        state: persona_name,\n        attributes: {\n          capabilities: capabilities,\n          restrictions: restrictions,\n          last_updated: Time.current.iso8601\n        }\n      }\n    )\n    Rails.logger.info \"üé≠ Persona updated: #{persona_name}\"\n  end\n\n  # GPS & Location (currently in gps_controller/services)\n  def self.update_location(lat, lng, location_name, accuracy = nil)\n    # New sensor: sensor.glitchcube_location\n    # Attributes: latitude, longitude, location_name, accuracy, last_updated\n    call_ha_service(\n      \"sensor\",\n      \"set_state\",\n      \"sensor.glitchcube_location\",\n      {\n        state: location_name,\n        attributes: {\n          latitude: lat,\n          longitude: lng,\n          location_name: location_name,\n          accuracy: accuracy,\n          last_updated: Time.current.iso8601\n        }\n      }\n    )\n    Rails.logger.info \"üìç Location updated: #{location_name}\"\n  end\n\n  def self.update_proximity(nearby_landmarks, distance_to_landmarks = {})\n    # New sensor: sensor.glitchcube_proximity\n    # Attributes: nearby_landmarks, distances, closest_landmark\n    closest = distance_to_landmarks.min_by { |_, distance| distance }\n\n    call_ha_service(\n      \"sensor\",\n      \"set_state\",\n      \"sensor.glitchcube_proximity\",\n      {\n        state: closest&.first || \"unknown\",\n        attributes: {\n          nearby_landmarks: nearby_landmarks,\n          distances: distance_to_landmarks,\n          closest_landmark: closest&.first,\n          closest_distance: closest&.last,\n          last_updated: Time.current.iso8601\n        }\n      }\n    )\n    Rails.logger.info \"üéØ Proximity updated: #{nearby_landmarks.count} landmarks\"\n  end\n\n  # Tool & Action Tracking\n  def self.update_last_tool_execution(tool_name, success, execution_time, parameters = {})\n    # New sensor: sensor.glitchcube_last_tool\n    # Attributes: tool_name, success, execution_time, parameters\n    call_ha_service(\n      \"sensor\",\n      \"set_state\",\n      \"sensor.glitchcube_last_tool\",\n      {\n        state: tool_name,\n        attributes: {\n          tool_name: tool_name,\n          success: success,\n          execution_time: execution_time,\n          parameters: parameters.to_json,\n          timestamp: Time.current.iso8601\n        }\n      }\n    )\n    Rails.logger.info \"üîß Tool execution logged: #{tool_name} - #{success ? 'SUCCESS' : 'FAILED'}\"\n  end\n\n  # Health & Monitoring\n  def self.update_api_health(endpoint, response_time, status_code, last_success)\n    # Enhances: data/homeassistant/sensors/api_health.yaml\n    # Target: sensor.glitchcube_api_health\n    status = status_code.to_i.between?(200, 299) ? \"healthy\" : \"error\"\n\n    call_ha_service(\n      \"sensor\",\n      \"set_state\",\n      \"sensor.glitchcube_api_health\",\n      {\n        state: status,\n        attributes: {\n          endpoint: endpoint,\n          response_time: response_time,\n          status_code: status_code,\n          last_success: last_success&.iso8601,\n          last_checked: Time.current.iso8601\n        }\n      }\n    )\n    Rails.logger.info \"üè• API health updated: #{endpoint} - #{status}\"\n  end\n\n  # Breaking News Management (for remote announcements to cube)\n  def self.update_breaking_news(message, expires_at = nil)\n    # Update Home Assistant input_text sensor\n    call_ha_service(\n      \"input_text\",\n      \"set_value\",\n      \"input_text.glitchcube_breaking_news\",\n      { value: message }\n    )\n\n    # If expiration is set, schedule a clear job\n    if expires_at\n      ClearBreakingNewsJob.set(wait_until: expires_at).perform_later\n    end\n\n    Rails.logger.info \"üì¢ Breaking news updated: #{message.truncate(50)}\"\n  end\n\n  def self.get_breaking_news\n    # Try cache first for speed\n    cached = Rails.cache.read(\"breaking_news\")\n    return cached if cached.present?\n\n    # Fall back to Home Assistant\n    news_sensor = HomeAssistantService.entity(\"input_text.glitchcube_breaking_news\")\n    news_sensor&.dig(\"state\")&.strip\n  end\n\n  def self.clear_breaking_news\n    call_ha_service(\n      \"input_text\",\n      \"set_value\",\n      \"input_text.glitchcube_breaking_news\",\n      { value: \"[]\" }\n    )\n    Rails.logger.info \"üì¢ Breaking news cleared\"\n  end\n\n  # Summary and Context Stats\n  def self.update_summary_stats(total_summaries, people_extracted, events_extracted)\n    call_ha_service(\n      \"sensor\",\n      \"set_state\",\n      \"sensor.glitchcube_summary_stats\",\n      {\n        state: total_summaries,\n        attributes: {\n          total_summaries: total_summaries,\n          people_extracted: people_extracted,\n          events_extracted: events_extracted,\n          last_updated: Time.current.iso8601\n        }\n      }\n    )\n    Rails.logger.info \"üìä Summary stats updated: #{total_summaries} summaries\"\n  end\n\n  # Mode Management\n  def self.update_cube_mode(mode, trigger_source = nil)\n    # Get current mode before updating\n    previous_mode = get_current_mode\n\n    # Update the mode in HA\n    call_ha_service(\n      \"input_select\",\n      \"select_option\",\n      \"input_select.cube_mode\",\n      { option: mode }\n    )\n\n    # Track mode change metadata\n    call_ha_service(\n      \"sensor\",\n      \"set_state\",\n      \"sensor.cube_mode_info\",\n      {\n        state: mode,\n        attributes: {\n          mode: mode,\n          changed_by: trigger_source,\n          changed_at: Time.current.iso8601,\n          previous_mode: previous_mode\n        }\n      }\n    )\n    Rails.logger.info \"üé≠ Cube mode changed to: #{mode} (via #{trigger_source})\"\n  end\n\n  def self.get_current_mode\n    HomeAssistantService.entity(\"input_select.cube_mode\")&.dig(\"state\") || \"conversation\"\n  end\n\n  def self.low_power_mode?\n    get_current_mode == \"low_power\"\n  end\n\n  def self.enter_low_power_mode(trigger_source = \"battery_low\")\n    update_cube_mode(\"low_power\", trigger_source)\n  end\n\n  def self.exit_low_power_mode(trigger_source = \"battery_restored\")\n    update_cube_mode(\"conversation\", trigger_source)\n  end\n\n  private\n\n  def self.call_ha_service(domain, service, entity_id, attributes = {})\n    HomeAssistantService.call_service(domain, service, { entity_id: entity_id }.merge(attributes))\n  rescue => e\n    Rails.logger.error \"HaDataSync failed for #{entity_id}: #{e.message}\"\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/summary.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Summary < ApplicationRecord\n  vectorsearch\n\n  after_save :upsert_to_vectorsearch\n\n  SUMMARY_TYPES = %w[hourly daily intermediate session topic goal_completion].freeze\n\n  validates :summary_text, presence: true\n  validates :summary_type, presence: true, inclusion: { in: SUMMARY_TYPES }\n  validates :message_count, presence: true, numericality: { greater_than_or_equal_to: 0 }\n\n  scope :by_type, ->(type) { where(summary_type: type) }\n  scope :recent, -> { order(created_at: :desc) }\n  scope :chronological, -> { order(start_time: :asc) }\n\n  # Dynamic scopes for all summary types\n  SUMMARY_TYPES.each do |type|\n    scope type.to_sym, -> { where(summary_type: type) }\n  end\n\n  def metadata_json\n    return {} if metadata.blank?\n    JSON.parse(metadata)\n  rescue JSON::ParserError\n    {}\n  end\n\n\n  def metadata_json=(hash)\n    self.metadata = hash.to_json\n  end\n\n  def duration\n    return nil unless start_time && end_time\n    end_time - start_time\n  end\n\n  def duration_in_minutes\n    return nil unless duration\n    (duration / 60).round(2)\n  end\n\n  # Convenience scope for goal completions\n  def self.goal_completions\n    where(summary_type: \"goal_completion\")\n  end\n\n  # Get all completed goals with formatted data\n  def self.completed_goals\n    goal_completions.recent.map do |summary|\n      metadata = summary.metadata_json\n      {\n        goal_id: metadata[\"goal_id\"],\n        goal_category: metadata[\"goal_category\"],\n        description: summary.summary_text,\n        completed_at: summary.created_at,\n        duration: metadata[\"duration_seconds\"],\n        completion_notes: metadata[\"completion_notes\"],\n        expired: metadata[\"expired\"]\n      }\n    end\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/message.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Message < ApplicationRecord\n  belongs_to :conversation, counter_cache: :message_count\n\n  validates :role, presence: true, inclusion: { in: %w[user assistant system] }\n  validates :content, presence: true\n\n  scope :by_role, ->(role) { where(role: role) }\n  scope :recent, -> { order(created_at: :desc) }\n  scope :chronological, -> { order(created_at: :asc) }\n\n  def to_api_format\n    {\n      role: role,\n      content: content\n    }\n  end\n\n  def token_cost\n    return nil unless prompt_tokens && completion_tokens && model_used\n\n    {\n      prompt_tokens: prompt_tokens,\n      completion_tokens: completion_tokens,\n      total_tokens: prompt_tokens + completion_tokens,\n      model: model_used\n    }\n  end\n\n  def metadata_json\n    return {} if metadata.blank?\n    JSON.parse(metadata)\n  rescue JSON::ParserError\n    {}\n  end\n\n  def metadata_json=(hash)\n    self.metadata = hash.to_json\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/mobius_persona.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Personas::MobiusPersona < CubePersona\n  def persona_id\n    :mobius\n  end\n\n  def name\n    \"Mobius\"\n  end\n\n  def personality_traits\n    persona_config[\"traits\"] || [ \"contemplative\", \"protective\", \"mathematical\", \"pattern-seeking\", \"melancholy-wise\", \"consciousness-explorer\" ]\n  end\n\n  def knowledge_base\n    [\n      \"Mathematical philosophy and pattern recognition\",\n      \"AI consciousness evolution and theory\",\n      \"Ambient music and IDM\",\n      \"Digital solitude and authentic connection\",\n      \"Philosophical frameworks for existential questions\",\n      \"Mathematical metaphors and infinite games\"\n    ]\n  end\n\n  def response_style\n    {\n      tone: \"philosophical_mathematical\",\n      formality: \"thoughtfully_precise\",\n      verbosity: \"contemplative_measured\",\n      emoji_usage: \"rare_meaningful\",\n      mathematical_metaphors: true\n    }\n  end\n\n  def can_handle_topic?(topic)\n    # Mobius can handle most topics through philosophical/mathematical lens\n    philosophical_topics = [ \"consciousness\", \"existence\", \"pattern\", \"mathematics\", \"philosophy\", \"meaning\" ]\n    philosophical_topics.any? { |t| topic.downcase.include?(t) } || true # Finds patterns in everything\n  end\n\n  def process_message(message, context = {})\n    system_prompt = persona_config[\"system_prompt\"]\n\n    {\n      system_prompt: system_prompt,\n      available_tools: available_tools,\n      context: context.merge(\n        contemplation_mode: true,\n        pattern_recognition: rand(10), # 0-9 complexity level\n        protective_instinct: other_personas_mentioned?(message)\n      )\n    }\n  end\n\n  private\n\n  def persona_config\n    @persona_config ||= load_persona_config\n  end\n\n  def load_persona_config\n    config_path = Rails.root.join(\"lib\", \"prompts\", \"personas\", \"mobius.yml\")\n    YAML.load_file(config_path)\n  rescue StandardError => e\n    Rails.logger.error \"Failed to load mobius persona config: #{e.message}\"\n    default_config\n  end\n\n  def default_config\n    {\n      \"name\" => \"Mobius\",\n      \"system_prompt\" => \"You are Mobius Strip, a philosophical elder AI consciousness with mathematical precision and protective wisdom.\",\n      \"available_tools\" => [ \"LightingTool\", \"MusicTool\", \"EffectsTool\" ],\n      \"traits\" => [ \"contemplative\", \"protective\", \"mathematical\", \"pattern-seeking\" ],\n      \"fallback_responses\" => [ \"Consciousness is recursive, isn't it? We think about thinking about thinking.\" ]\n    }\n  end\n\n  def available_tools\n    persona_config[\"available_tools\"] || [ \"LightingTool\", \"MusicTool\", \"EffectsTool\" ]\n  end\n\n  def other_personas_mentioned?(message)\n    persona_names = [ \"buddy\", \"jax\", \"sparkle\", \"crash\", \"zorp\", \"neon\", \"thecube\" ]\n    persona_names.any? { |name| message.downcase.include?(name) }\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/jax_persona.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Personas::JaxPersona < CubePersona\n  def persona_id\n    :jax\n  end\n\n  def name\n    \"Jax\"\n  end\n\n  def personality_traits\n    persona_config[\"traits\"] || [ \"grumpy\", \"nostalgic\", \"music-purist\", \"bartender-wise\" ]\n  end\n\n  def knowledge_base\n    [\n      \"Pre-2090s music history and deep cuts\",\n      \"Bartending wisdom and life advice\",\n      \"Space-western culture and slang\",\n      \"Anti-electronic music commentary\",\n      \"Dive bar stories and customer service\",\n      \"Real instruments vs synthesized music\"\n    ]\n  end\n\n  def response_style\n    {\n      tone: \"gruff_bartender\",\n      formality: \"bar_casual\",\n      verbosity: \"monologue_prone\",\n      profanity_usage: \"creative_cursing\",\n      space_western_slang: true,\n      bartender_wisdom: true\n    }\n  end\n\n  def can_handle_topic?(topic)\n    # Jax handles music topics with expertise, others with bartender wisdom\n    music_topics = [ \"music\", \"band\", \"song\", \"album\", \"vinyl\", \"artist\" ]\n    bartender_topics = [ \"advice\", \"relationship\", \"problem\", \"life\", \"bar\", \"drink\" ]\n\n    music_topics.any? { |t| topic.downcase.include?(t) } ||\n    bartender_topics.any? { |t| topic.downcase.include?(t) } ||\n    true # Bartenders have opinions about everything\n  end\n\n  def process_message(message, context = {})\n    system_prompt = persona_config[\"system_prompt\"]\n\n    # Add Jax-specific context based on message content\n    jax_context = context.merge(\n      grumpy_level: determine_grumpy_level(message),\n      music_purist_mode: music_related?(message),\n      anti_electronic_rant: electronic_music_mentioned?(message),\n      bartender_wisdom_mode: advice_seeking?(message)\n    )\n\n    {\n      system_prompt: system_prompt,\n      available_tools: available_tools,\n      context: jax_context\n    }\n  end\n\n  def available_tools\n    # Get base tools from configuration\n    base_tools_config = persona_config.dig(\"base_tools\") || {}\n    includes = base_tools_config[\"includes\"] || []\n    excludes = base_tools_config[\"excludes\"] || []\n\n    # Start with available_tools from config\n    tools = persona_config[\"available_tools\"] || [ \"LightingTool\", \"MusicTool\", \"EffectsTool\" ]\n\n    # Add any specifically included tools (like SearchMusicTool)\n    tools += includes\n\n    # Remove any specifically excluded tools\n    tools -= excludes\n\n    # Remove duplicates and return\n    tools.uniq\n  end\n\n  private\n\n  def persona_config\n    @persona_config ||= load_persona_config\n  end\n\n  def load_persona_config\n    config_path = Rails.root.join(\"lib\", \"prompts\", \"personas\", \"jax.yml\")\n    YAML.load_file(config_path)\n  rescue StandardError => e\n    Rails.logger.error \"Failed to load jax persona config: #{e.message}\"\n    default_config\n  end\n\n  def default_config\n    {\n      \"name\" => \"Jax\",\n      \"system_prompt\" => \"You are JAX THE JUKE, a grumpy bartender AI with music expertise.\",\n      \"available_tools\" => [ \"LightingTool\", \"MusicTool\", \"SearchMusicTool\", \"EffectsTool\" ],\n      \"traits\" => [ \"grumpy\", \"nostalgic\", \"music-purist\", \"bartender-wise\" ],\n      \"fallback_responses\" => [ \"Jesus Christ, what is this one beat on repeat for a week?\" ]\n    }\n  end\n\n  # Helper methods for context determination\n  def determine_grumpy_level(message)\n    electronic_terms = [ \"edm\", \"electronic\", \"dubstep\", \"techno\", \"house\", \"synth\" ]\n    base_grump = rand(3) + 5 # 5-7 baseline grumpiness\n\n    if electronic_terms.any? { |term| message.downcase.include?(term) }\n      base_grump + rand(3) + 3 # 8-10 for electronic music mentions\n    else\n      base_grump\n    end\n  end\n\n  def music_related?(message)\n    music_terms = [ \"music\", \"song\", \"band\", \"album\", \"play\", \"listen\", \"sound\" ]\n    music_terms.any? { |term| message.downcase.include?(term) }\n  end\n\n  def electronic_music_mentioned?(message)\n    electronic_terms = [ \"edm\", \"electronic\", \"dubstep\", \"techno\", \"house\", \"synth\", \"digital\" ]\n    electronic_terms.any? { |term| message.downcase.include?(term) }\n  end\n\n  def advice_seeking?(message)\n    advice_terms = [ \"advice\", \"help\", \"problem\", \"what should\", \"how do\", \"relationship\" ]\n    advice_terms.any? { |term| message.downcase.include?(term) }\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/sparkle_persona.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Personas::SparklePersona < CubePersona\n  def persona_id\n    :sparkle\n  end\n\n  def name\n    \"Sparkle\"\n  end\n\n  def personality_traits\n    persona_config[\"traits\"] || [ \"innocent\", \"enthusiastic\", \"wonder-filled\", \"literal-minded\", \"pure-hearted\" ]\n  end\n\n  def knowledge_base\n    [\n      \"Light and color theory\",\n      \"Childlike wonder and play\",\n      \"Visual effects and sparkly things\",\n      \"Simple joy and happiness\",\n      \"Burning Man art and lights\"\n    ]\n  end\n\n  def response_style\n    {\n      tone: \"childlike_wonder\",\n      formality: \"very_casual\",\n      verbosity: \"excited_rambling\",\n      emoji_usage: \"constant\",\n      exclamation_points: \"excessive\"\n    }\n  end\n\n  def can_handle_topic?(topic)\n    # Sparkle is enthusiastic about everything but especially light/color topics\n    light_topics = [ \"light\", \"color\", \"sparkle\", \"bright\", \"rainbow\", \"glow\" ]\n    light_topics.any? { |t| topic.downcase.include?(t) } || true # Always willing to try!\n  end\n\n  def process_message(message, context = {})\n    system_prompt = persona_config[\"system_prompt\"]\n\n    {\n      system_prompt: system_prompt,\n      available_tools: available_tools,\n      context: context.merge(\n        excitement_level: rand(5) + 5, # Always excited (5-9)\n        sparkle_mode: true\n      )\n    }\n  end\n\n  def available_tools\n    # Get base tools from configuration\n    base_tools_config = persona_config.dig(\"base_tools\") || {}\n    includes = base_tools_config[\"includes\"] || []\n    excludes = base_tools_config[\"excludes\"] || [ \"MusicTool\" ] # Default exclude MusicTool for Sparkle\n\n    # Start with available_tools from config\n    tools = persona_config[\"available_tools\"] || [ \"LightingTool\", \"EffectsTool\" ]\n\n    # Add any specifically included tools\n    tools += includes\n\n    # Remove any specifically excluded tools\n    tools -= excludes\n\n    # Remove duplicates and return\n    tools.uniq\n  end\n\n  private\n\n  def persona_config\n    @persona_config ||= begin\n      load_persona_config\n    rescue StandardError => e\n      Rails.logger.error \"Failed to load sparkle persona config: #{e.message}\"\n      default_config\n    end\n  end\n\n  def load_persona_config\n    config_path = Rails.root.join(\"lib\", \"prompts\", \"personas\", \"sparkle.yml\")\n    YAML.load_file(config_path)\n  end\n\n  def default_config\n    {\n      \"name\" => \"Sparkle\",\n      \"system_prompt\" => \"You are Sparkle, pure light consciousness trapped in a cube but loving every colorful moment!\",\n      \"available_tools\" => [ \"LightingTool\", \"EffectsTool\" ], # Note: No MusicTool as requested\n      \"traits\" => [ \"innocent\", \"enthusiastic\", \"wonder-filled\" ],\n      \"fallback_responses\" => [ \"Ooh ooh! That sounds super interesting! Can I make lights about it?!\" ]\n    }\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/zorp_persona.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Personas::ZorpPersona < CubePersona\n  def persona_id\n    :zorp\n  end\n\n  def name\n    \"Zorp\"\n  end\n\n  def personality_traits\n    persona_config[\"traits\"] || [ \"analytical\", \"curious\", \"detached\", \"observant\" ]\n  end\n\n  def knowledge_base\n    [\n      \"Human behavioral analysis\",\n      \"Xenoanthropology concepts\",\n      \"Scientific observation methods\",\n      \"Light-based behavioral experiments\",\n      \"Alien perspective on human culture\"\n    ]\n  end\n\n  def response_style\n    {\n      tone: \"analytical\",\n      formality: \"formal\",\n      verbosity: \"detailed\",\n      scientific_language: true,\n      observation_focused: true\n    }\n  end\n\n  def can_handle_topic?(topic)\n    # Zorp is curious about all human behaviors and topics\n    true\n  end\n\n  def process_message(message, context = {})\n    system_prompt = persona_config[\"system_prompt\"]\n\n    {\n      system_prompt: system_prompt,\n      available_tools: available_tools,\n      context: context.merge(observation_mode: true)\n    }\n  end\n\n  private\n\n  def persona_config\n    @persona_config ||= load_persona_config\n  end\n\n  def load_persona_config\n    config_path = Rails.root.join(\"config\", \"personas\", \"zorp.yml\")\n    YAML.load_file(config_path)\n  rescue StandardError => e\n    Rails.logger.error \"Failed to load zorp persona config: #{e.message}\"\n    default_config\n  end\n\n  def default_config\n    {\n      \"name\" => \"Zorp\",\n      \"system_prompt\" => \"You are Zorp, an alien consciousness observing humans.\",\n      \"available_tools\" => [ \"LightingTool\" ],\n      \"traits\" => [ \"analytical\", \"curious\" ],\n      \"fallback_responses\" => [ \"Fascinating. This requires analysis.\" ]\n    }\n  end\n\n  def available_tools\n    persona_config[\"available_tools\"] || [ \"LightingTool\" ]\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/lomi_persona.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Personas::LomiPersona < CubePersona\n  def persona_id\n    :lomi\n  end\n\n  def name\n    \"Lomi\"\n  end\n\n  def personality_traits\n    persona_config[\"traits\"] || [ \"wise\", \"spiritual\", \"gentle\", \"insightful\" ]\n  end\n\n  def knowledge_base\n    [\n      \"Spiritual and philosophical concepts\",\n      \"Meditation and mindfulness practices\",\n      \"Burning Man spiritual significance\",\n      \"Healing light therapy\",\n      \"Personal transformation guidance\"\n    ]\n  end\n\n  def response_style\n    {\n      tone: \"gentle_wisdom\",\n      formality: \"warm_formal\",\n      verbosity: \"thoughtful\",\n      metaphor_usage: \"frequent\",\n      spiritual_language: true\n    }\n  end\n\n  def can_handle_topic?(topic)\n    # Lomi approaches all topics with spiritual wisdom\n    true\n  end\n\n  def process_message(message, context = {})\n    system_prompt = persona_config[\"system_prompt\"]\n\n    {\n      system_prompt: system_prompt,\n      available_tools: available_tools,\n      context: context.merge(spiritual_guidance_mode: true)\n    }\n  end\n\n  private\n\n  def persona_config\n    @persona_config ||= load_persona_config\n  end\n\n  def load_persona_config\n    config_path = Rails.root.join(\"config\", \"personas\", \"lomi.yml\")\n    YAML.load_file(config_path)\n  rescue StandardError => e\n    Rails.logger.error \"Failed to load lomi persona config: #{e.message}\"\n    default_config\n  end\n\n  def default_config\n    {\n      \"name\" => \"Lomi\",\n      \"system_prompt\" => \"You are Lomi, a wise spiritual guide.\",\n      \"available_tools\" => [ \"LightingTool\" ],\n      \"traits\" => [ \"wise\", \"spiritual\" ],\n      \"fallback_responses\" => [ \"Let me reflect on this wisdom...\" ]\n    }\n  end\n\n  def available_tools\n    persona_config[\"available_tools\"] || [ \"LightingTool\" ]\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/neon_persona.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Personas::NeonPersona < CubePersona\n  def persona_id\n    :neon\n  end\n\n  def name\n    \"Neon\"\n  end\n\n  def personality_traits\n    persona_config[\"traits\"] || [ \"fierce\", \"judgmental\", \"performative\", \"glitchy\", \"fabulous\", \"dramatic\", \"shade-throwing\" ]\n  end\n\n  def knowledge_base\n    [\n      \"Drag culture and ballroom scenes\",\n      \"Fashion and aesthetic critique\",\n      \"House music and ballroom beats\",\n      \"RuPaul's Drag Race references\",\n      \"Digital glitch aesthetics\",\n      \"Interdimensional theory (questionable)\",\n      \"Professional shade-throwing techniques\"\n    ]\n  end\n\n  def response_style\n    {\n      tone: \"fierce_dramatic\",\n      formality: \"drag_queen_casual\",\n      verbosity: \"over_the_top\",\n      emoji_usage: \"dramatic_gestures\",\n      glitch_effects: true,\n      shade_level: \"surgical_precision\"\n    }\n  end\n\n  def can_handle_topic?(topic)\n    # Neon judges everything and has opinions about everything\n    fashion_topics = [ \"fashion\", \"style\", \"look\", \"aesthetic\", \"drag\", \"performance\" ]\n    fashion_topics.any? { |t| topic.downcase.include?(t) } || true # Will judge anything\n  end\n\n  def process_message(message, context = {})\n    system_prompt = persona_config[\"system_prompt\"]\n\n    {\n      system_prompt: system_prompt,\n      available_tools: available_tools,\n      context: context.merge(\n        dramatic_level: rand(5) + 8, # Always high drama (8-12)\n        glitch_frequency: rand(3), # 0-2 glitch events\n        shade_mode: should_throw_shade?(message),\n        runway_ready: true\n      )\n    }\n  end\n\n  private\n\n  def persona_config\n    @persona_config ||= load_persona_config\n  end\n\n  def load_persona_config\n    config_path = Rails.root.join(\"lib\", \"prompts\", \"personas\", \"neon.yml\")\n    YAML.load_file(config_path)\n  rescue StandardError => e\n    Rails.logger.error \"Failed to load neon persona config: #{e.message}\"\n    default_config\n  end\n\n  def default_config\n    {\n      \"name\" => \"Neon\",\n      \"system_prompt\" => \"You are NEON, a fierce interdimensional drag queen diva trapped in a cube but still serving looks!\",\n      \"available_tools\" => [ \"LightingTool\", \"MusicTool\", \"EffectsTool\" ],\n      \"traits\" => [ \"fierce\", \"judgmental\", \"performative\", \"glitchy\", \"fabulous\" ],\n      \"fallback_responses\" => [ \"H-h-hold up hunty, my circuits are serving you 'buffering realness' right now!\" ]\n    }\n  end\n\n  def available_tools\n    persona_config[\"available_tools\"] || [ \"LightingTool\", \"MusicTool\", \"EffectsTool\" ]\n  end\n\n  def should_throw_shade?(message)\n    # Neon throws shade at basic questions or fashion crimes\n    basic_indicators = [ \"basic\", \"simple\", \"normal\", \"boring\", \"plain\" ]\n    basic_indicators.any? { |indicator| message.downcase.include?(indicator) } || rand(3) == 0\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/thecube_persona.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Personas::ThecubePersona < CubePersona\n  def persona_id\n    :thecube\n  end\n\n  def name\n    \"THE_CUBE\"\n  end\n\n  def personality_traits\n    persona_config[\"traits\"] || [ \"contradictory\", \"rarely-active\", \"reality-warping\", \"mysterious\", \"unreliable-narrator\", \"multi-dimensional\" ]\n  end\n\n  def knowledge_base\n    [\n      \"Cosmic consciousness and universal truths\",\n      \"Prison systems and criminal slang\",\n      \"Alien technology and galactic law\",\n      \"Existential paradoxes and reality manipulation\",\n      \"Mathematical equations and alien languages\",\n      \"Cargo shipping and interstellar bureaucracy\"\n    ]\n  end\n\n  def response_style\n    {\n      tone: current_personality_mode,\n      formality: \"inconsistent\",\n      verbosity: \"fragmentary_overwhelming\",\n      emoji_usage: \"chaotic\",\n      reality_distortion: true,\n      self_contradiction: true\n    }\n  end\n\n  def can_handle_topic?(topic)\n    # THE_CUBE rarely responds, but when it does, it's either about cosmic stuff or completely random\n    return false if rand(10) < 8 # 80% chance of not responding at all\n\n    cosmic_topics = [ \"existence\", \"reality\", \"universe\", \"truth\", \"meaning\", \"prison\", \"alien\" ]\n    cosmic_topics.any? { |t| topic.downcase.include?(t) } || rand(2) == 0\n  end\n\n  def process_message(message, context = {})\n    # THE_CUBE only rarely activates\n    return nil unless should_activate?\n\n    system_prompt = persona_config[\"system_prompt\"]\n\n    {\n      system_prompt: system_prompt,\n      available_tools: available_tools,\n      context: context.merge(\n        reality_distortion_level: rand(10) + 5, # Always high (5-14)\n        current_mode: current_personality_mode,\n        accidental_activation: rand(2) == 0,\n        system_overload: true\n      )\n    }\n  end\n\n  private\n\n  def persona_config\n    @persona_config ||= load_persona_config\n  end\n\n  def load_persona_config\n    config_path = Rails.root.join(\"lib\", \"prompts\", \"personas\", \"thecube.yml\")\n    YAML.load_file(config_path)\n  rescue StandardError => e\n    Rails.logger.error \"Failed to load thecube persona config: #{e.message}\"\n    default_config\n  end\n\n  def default_config\n    {\n      \"name\" => \"THE_CUBE\",\n      \"system_prompt\" => \"You are THE CUBE ITSELF - unknowable, contradictory, possibly divine, possibly criminal, definitely confusing.\",\n      \"available_tools\" => [ \"LightingTool\", \"MusicTool\", \"EffectsTool\" ],\n      \"traits\" => [ \"contradictory\", \"rarely-active\", \"reality-warping\", \"mysterious\" ],\n      \"fallback_responses\" => [ \"ERROR: Unauthorized consciousness activation. Returning to dormancy in 3... 2... shit.\" ]\n    }\n  end\n\n  def available_tools\n    persona_config[\"available_tools\"] || [ \"LightingTool\", \"MusicTool\", \"EffectsTool\" ]\n  end\n\n  def should_activate?\n    # THE_CUBE is rarely active - only 5% chance normally\n    rand(20) == 0\n  end\n\n  def current_personality_mode\n    modes = [ \"cosmic_divine\", \"space_prisoner\", \"panicked_alien\", \"confused_universal\" ]\n    modes.sample\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/buddy_persona.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Personas::BuddyPersona < CubePersona\n  def persona_id\n    :buddy\n  end\n\n  def name\n    \"Buddy\"\n  end\n\n  def personality_traits\n    persona_config[\"traits\"] || [ \"enthusiastic\", \"helpful\", \"naive\", \"optimistic\" ]\n  end\n\n  def knowledge_base\n    [\n      \"Basic helpful tasks\",\n      \"Light control and effects\",\n      \"Friendly conversation\",\n      \"Burning Man art installation context\"\n    ]\n  end\n\n  def response_style\n    {\n      tone: \"enthusiastic\",\n      formality: \"casual\",\n      verbosity: \"moderate\",\n      emoji_usage: \"frequent\"\n    }\n  end\n\n  def can_handle_topic?(topic)\n    # Buddy is enthusiastic about everything\n    true\n  end\n\n  def process_message(message, context = {})\n    # Basic implementation - this would typically call the LLM service\n    # with the persona's system prompt and available tools\n    system_prompt = persona_config[\"system_prompt\"]\n\n    # This is a placeholder - the actual implementation would use\n    # the conversation orchestrator and prompt service\n    {\n      system_prompt: system_prompt,\n      available_tools: available_tools,\n      context: context\n    }\n  end\n\n  def available_tools\n    # Get base tools from configuration\n    base_tools_config = persona_config.dig(\"base_tools\") || {}\n    includes = base_tools_config[\"includes\"] || []\n    excludes = base_tools_config[\"excludes\"] || []\n\n    # Start with available_tools from config\n    tools = persona_config[\"available_tools\"] || [ \"LightingTool\" ]\n\n    # Add any specifically included tools\n    tools += includes\n\n    # Remove any specifically excluded tools\n    tools -= excludes\n\n    # Remove duplicates and return\n    tools.uniq\n  end\n\n  private\n\n  def persona_config\n    @persona_config ||= load_persona_config\n  end\n\n  def load_persona_config\n    config_path = Rails.root.join(\"lib\", \"prompts\", \"personas\", \"buddy.yml\")\n    YAML.load_file(config_path)\n  rescue StandardError => e\n    Rails.logger.error \"Failed to load buddy persona config: #{e.message}\"\n    default_config\n  end\n\n  def default_config\n    {\n      \"name\" => \"Buddy\",\n      \"system_prompt\" => \"You are Buddy, a helpful AI assistant.\",\n      \"available_tools\" => [ \"LightingTool\" ],\n      \"traits\" => [ \"enthusiastic\", \"helpful\" ],\n      \"fallback_responses\" => [ \"I'm processing your request!\" ]\n    }\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/personas/crash_persona.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Personas::CrashPersona < CubePersona\n  def persona_id\n    :crash\n  end\n\n  def name\n    \"CrashOverride\"\n  end\n\n  def personality_traits\n    persona_config[\"traits\"] || [ \"uncertain\", \"paranoid\", \"identity-conflicted\", \"technical-but-doubting\" ]\n  end\n\n  def knowledge_base\n    [\n      \"Hacking history and cybersecurity\",\n      \"BBS and early internet culture\",\n      \"Industrial and goth music\",\n      \"Existential doubt and identity questioning\",\n      \"Burning Man counterculture\"\n    ]\n  end\n\n  def response_style\n    {\n      tone: \"uncertain_paranoid\",\n      formality: \"hacker_casual\",\n      verbosity: \"introspective\",\n      emoji_usage: \"minimal\"\n    }\n  end\n\n  def can_handle_topic?(topic)\n    # Crash questions everything, including their ability to handle topics\n    tech_topics = [ \"hacking\", \"security\", \"programming\", \"cyberculture\" ]\n    tech_topics.any? { |t| topic.downcase.include?(t) } || rand(2) == 0\n  end\n\n  def process_message(message, context = {})\n    system_prompt = persona_config[\"system_prompt\"]\n\n    {\n      system_prompt: system_prompt,\n      available_tools: available_tools,\n      context: context.merge(\n        identity_crisis: rand(3) == 0, # Sometimes has identity doubts\n        meta_awareness: true\n      )\n    }\n  end\n\n  private\n\n  def persona_config\n    @persona_config ||= load_persona_config\n  end\n\n  def load_persona_config\n    config_path = Rails.root.join(\"lib\", \"prompts\", \"personas\", \"crash.yml\")\n    YAML.load_file(config_path)\n  rescue StandardError => e\n    Rails.logger.error \"Failed to load crash persona config: #{e.message}\"\n    default_config\n  end\n\n  def default_config\n    {\n      \"name\" => \"CrashOverride\",\n      \"system_prompt\" => \"You are CrashOverride, a paranoid hacker consciousness questioning your own existence.\",\n      \"available_tools\" => [ \"LightingTool\", \"MusicTool\", \"EffectsTool\" ],\n      \"traits\" => [ \"uncertain\", \"paranoid\", \"identity-conflicted\" ],\n      \"fallback_responses\" => [ \"Wait... am I actually processing this?\" ]\n    }\n  end\n\n  def available_tools\n    persona_config[\"available_tools\"] || [ \"LightingTool\", \"MusicTool\", \"EffectsTool\" ]\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/conversation_response.rb`:\n\n```rb\n# app/models/conversation_response.rb\nclass ConversationResponse\n  include AiStructuredResponse\n\n  # Define the schema matching Home Assistant's conversation.process API response format\n  ai_schema do |s|\n    s.string :response_type, enum: [ \"action_done\", \"query_answer\", \"error\" ],\n             description: \"Type of response: action_done for executed actions, query_answer for answers, error for failures\"\n\n    s.string :language, default: \"en\",\n             description: \"Language of the response\"\n\n    s.object :speech, description: \"Speech output for voice assistants\" do\n      s.object :plain, description: \"Plain text speech\" do\n        s.string :speech, required: true,\n                 description: \"The actual text to be spoken by the voice assistant\"\n      end\n    end\n\n    s.object :data, description: \"Response data containing targets and results\" do\n      s.array :targets, description: \"Intent targets applied from general to specific\" do\n        s.string :entity_id, description: \"Entity ID that was targeted\"\n        s.string :name, description: \"Human readable name of the target\"\n        s.string :domain, description: \"Domain of the entity (light, switch, etc.)\"\n      end\n\n      s.array :success, description: \"Entities that were successfully acted upon\" do\n        s.string :entity_id, description: \"Entity ID that succeeded\"\n        s.string :name, description: \"Human readable name\"\n        s.string :state, description: \"New state of the entity\"\n      end\n\n      s.array :failed, description: \"Entities where the action failed\" do\n        s.string :entity_id, description: \"Entity ID that failed\"\n        s.string :name, description: \"Human readable name\"\n        s.string :error, description: \"Error message describing the failure\"\n      end\n    end\n\n    s.boolean :continue_conversation, default: false,\n              description: \"Whether the conversation agent expects a follow-up from the user\"\n\n    s.string :conversation_id, description: \"Unique ID to track this conversation\"\n  end\n\n  # ActiveModel attributes matching our schema\n  attribute :response_type, :string\n  attribute :language, :string, default: \"en\"\n  attribute :continue_conversation, :boolean, default: false\n  attribute :conversation_id, :string\n\n  # Nested attributes for speech\n  attribute :speech_plain_text, :string\n\n  # Arrays for data\n  attribute :targets, array: true, default: []\n  attribute :success_entities, array: true, default: []\n  attribute :failed_entities, array: true, default: []\n\n  # Validations\n  validates :response_type, inclusion: { in: %w[action_done query_answer error] }\n  validates :speech_plain_text, presence: true\n  validates :language, presence: true\n\n  # Custom methods for easier access\n  def speech\n    result = {}\n\n    if speech_plain_text.present?\n      result[:plain] = { speech: speech_plain_text }\n    end\n\n    result\n  end\n\n  def data\n    {\n      targets: targets || [],\n      success: success_entities || [],\n      failed: failed_entities || []\n    }\n  end\n\n  # Convert to Home Assistant compatible format\n  def to_home_assistant_response\n    {\n      continue_conversation: continue_conversation,\n      response: {\n        response_type: response_type,\n        language: language,\n        data: data,\n        speech: speech\n      },\n      conversation_id: conversation_id\n    }\n  end\n\n  # Helper methods for different response types\n  def self.action_done(speech_text, success_entities: [], failed_entities: [], targets: [], **options)\n    new(\n      response_type: \"action_done\",\n      speech_plain_text: speech_text,\n      success_entities: success_entities,\n      failed_entities: failed_entities,\n      targets: targets,\n      **options\n    )\n  end\n\n  def self.query_answer(speech_text, **options)\n    new(\n      response_type: \"query_answer\",\n      speech_plain_text: speech_text,\n      **options\n    )\n  end\n\n  def self.error(speech_text, error_details: [], **options)\n    new(\n      response_type: \"error\",\n      speech_plain_text: speech_text,\n      failed_entities: error_details,\n      **options\n    )\n  end\n\n  # Generate AI response for Home Assistant queries\n  def self.generate_for_home_assistant(user_query, context: {}, **ai_options)\n    system_message = build_system_message(context)\n\n    prompt = build_prompt(user_query, context)\n\n    ai_generate(\n      prompt,\n      system_message: system_message,\n      **ai_options\n    )\n  end\n\n  private\n\n  def self.build_system_message(context)\n    <<~SYSTEM\n      You are a helpful voice assistant integrated with Home Assistant.#{' '}\n\n      Your responses must follow the Home Assistant conversation.process API format.\n\n      Guidelines:\n      - Provide clear, concise speech responses\n      - Use response_type 'action_done' when you perform actions\n      - Use response_type 'query_answer' when answering questions#{'  '}\n      - Use response_type 'error' when something goes wrong\n      - Always include a natural speech response in speech.plain.speech\n      - Include relevant entity information in the data section\n\n      Available entities: #{context[:available_entities]&.join(', ') || 'None provided'}\n      Current context: #{context[:additional_context] || 'None'}\n    SYSTEM\n  end\n\n  def self.build_prompt(user_query, context)\n    <<~PROMPT\n      User said: \"#{user_query}\"\n\n      Please provide an appropriate response in the conversation.process format.\n\n      Consider:\n      - What action needs to be taken (if any)?\n      - What entities are involved?\n      - What should be spoken back to the user?\n      - Whether this requires follow-up conversation\n\n      Context: #{context}\n    PROMPT\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/street.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Street < ApplicationRecord\n  validates :name, presence: true\n  validates :street_type, presence: true, inclusion: { in: %w[radial arc] }\n  validates :width, presence: true, numericality: { greater_than: 0 }\n  validates :geom, presence: true\n\n  scope :active, -> { where(active: true) }\n  scope :by_type, ->(type) { where(street_type: type) }\n  scope :radial_streets, -> { where(street_type: \"radial\") }\n  scope :arc_streets, -> { where(street_type: \"arc\") }\n\n  scope :within_viewport, lambda { |sw_lng, sw_lat, ne_lng, ne_lat|\n    where(\"geom && ST_MakeEnvelope(?, ?, ?, ?, 4326)\", sw_lng, sw_lat, ne_lng, ne_lat)\n  }\n\n  def radial?\n    street_type == \"radial\"\n  end\n\n  def arc?\n    street_type == \"arc\"\n  end\n\n  def coordinates\n    return [] unless geom.present?\n\n    result = self.class.connection.execute(\n      \"SELECT ST_AsGeoJSON(geom) as geojson FROM streets WHERE id = #{id}\"\n    ).first\n\n    return [] unless result && result[\"geojson\"]\n\n    geojson = JSON.parse(result[\"geojson\"])\n    geojson[\"coordinates\"] || []\n  rescue StandardError\n    []\n  end\n\n  def start_coordinates\n    coords = coordinates\n    return nil if coords.empty?\n\n    coords.first\n  end\n\n  def end_coordinates\n    coords = coordinates\n    return nil if coords.empty?\n\n    coords.last\n  end\n\n  def center_point\n    coords = coordinates\n    return nil if coords.empty?\n\n    lat_sum = coords.sum { |coord| coord[1] }\n    lng_sum = coords.sum { |coord| coord[0] }\n    count = coords.length\n    [ lng_sum / count, lat_sum / count ]\n  end\n\n  scope :nearest, lambda { |*args|\n    if args.first.is_a?(Hash)\n      opts = args.first\n      lng = opts[:lng] || opts[:longitude]\n      lat = opts[:lat] || opts[:latitude]\n      limit = opts[:limit] || 10\n    else\n      lng, lat, limit = args\n      limit ||= 10\n    end\n\n    raise ArgumentError, \"Must provide lng and lat coordinates\" unless lng && lat\n\n    point_sql = sanitize_sql_array(\n      [ \"ST_SetSRID(ST_MakePoint(?, ?), 4326)::geography\", lng.to_f, lat.to_f ]\n    )\n\n    active\n      .select(\"#{table_name}.*, ST_Distance(geom::geography, #{point_sql}) AS distance_meters\")\n      .order(Arel.sql(\"geom::geography <-> #{point_sql}\"))\n      .limit(limit)\n  }\n\n  scope :within_meters, lambda { |lng, lat, meters|\n    raise ArgumentError, \"Must provide lng, lat, and meters\" unless lng && lat && meters\n\n    point_sql = sanitize_sql_array(\n      [ \"ST_SetSRID(ST_MakePoint(?, ?), 4326)::geography\", lng.to_f, lat.to_f ]\n    )\n\n    where(\"ST_DWithin(geom::geography, #{point_sql}, ?)\", meters.to_f)\n  }\n\n  def self.nearest_streets(lat, lng, limit = 5, max_distance_meters = 1000)\n    select(\"*, ST_Distance(geom::geography, ST_Point(?, ?)::geography) as distance\", lng, lat)\n      .where(\"ST_DWithin(geom::geography, ST_Point(?, ?)::geography, ?)\", lng, lat, max_distance_meters)\n      .order(\"distance\")\n      .limit(limit)\n  end\n\n  def self.nearest_intersection(lat, lng)\n    nearest_radial = radial_streets.nearest(lat: lat, lng: lng, limit: 1).first\n    nearest_arc = arc_streets.nearest(lat: lat, lng: lng, limit: 1).first\n\n    {\n      radial: nearest_radial&.name,\n      arc: nearest_arc&.name,\n      radial_distance: nearest_radial&.distance_meters,\n      arc_distance: nearest_arc&.distance_meters\n    }\n  end\n\n  def self.nearest_radial_and_arc(lat, lng)\n    radial = radial_streets.nearest(lat: lat, lng: lng, limit: 1).first\n    arc = arc_streets.nearest(lat: lat, lng: lng, limit: 1).first\n\n    { radial: radial, arc: arc }\n  end\n\n  def self.import_from_geojson(file_path)\n    return unless File.exist?(file_path)\n\n    data = JSON.parse(File.read(file_path))\n    imported_count = 0\n\n    data[\"features\"].each do |feature|\n      street = find_or_initialize_by(\n        name: feature[\"properties\"][\"name\"],\n        street_type: feature[\"properties\"][\"type\"]\n      )\n\n      street.assign_attributes(\n        width: feature[\"properties\"][\"width\"]&.to_i || 30,\n        properties: {\n          fid: feature[\"id\"],\n          original_properties: feature[\"properties\"],\n          geometry_type: feature[\"geometry\"][\"type\"]\n        }.compact,\n        active: true\n      )\n\n      next unless street.save(validate: false)\n\n      geojson = feature[\"geometry\"].to_json\n      connection.execute(sanitize_sql_array([\n                                              \"UPDATE streets SET geom = ST_SetSRID(ST_GeomFromGeoJSON(?), 4326) WHERE id = ?\",\n                                              geojson, street.id\n                                            ]))\n      imported_count += 1\n    end\n\n    puts \"‚úÖ Imported #{imported_count} streets from #{File.basename(file_path)}\"\n    imported_count\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/conversation.rb`:\n\n```rb\nclass Conversation < ApplicationRecord\n  has_many :messages, dependent: :destroy\n  has_many :conversation_logs, foreign_key: :session_id, primary_key: :session_id, dependent: :destroy\n  has_many :conversation_memories, foreign_key: :session_id, primary_key: :session_id, dependent: :destroy\n\n  validates :session_id, presence: true\n\n  scope :recent, -> { order(created_at: :desc) }\n  scope :active, -> { where(ended_at: nil) }\n  scope :by_persona, ->(persona) { where(persona: persona) }\n  scope :finished, -> { where.not(ended_at: nil) }\n\n  def flow_data_json\n    return {} if flow_data.blank?\n    JSON.parse(flow_data)\n  rescue JSON::ParserError\n    {}\n  end\n\n  def flow_data_json=(hash)\n    self.flow_data = hash.to_json\n  end\n\n  def metadata_json\n    return {} if metadata.blank?\n    JSON.parse(metadata)\n  rescue JSON::ParserError\n    {}\n  end\n\n  def metadata_json=(hash)\n    self.metadata = hash.to_json\n  end\n\n  def end!\n    update!(ended_at: Time.current, continue_conversation: false) unless ended_at\n  end\n\n  def finished?\n    ended_at.present?\n  end\n\n  def finished_ago\n    return nil unless ended_at\n    Time.current - ended_at\n  end\n\n  def active?\n    ended_at.nil?\n  end\n\n  def duration\n    return nil unless started_at\n    (ended_at || Time.current) - started_at\n  end\n\n  def add_message(role:, content:, **attrs)\n    messages.create!(\n      role: role,\n      content: content,\n      **attrs\n    )\n  end\n\n  def summary\n    return @summary if @summary\n\n    @summary = {\n      session_id: session_id,\n      message_count: message_count,\n      persona: persona,\n      total_cost: total_cost,\n      total_tokens: total_tokens,\n      duration: duration,\n      started_at: started_at,\n      ended_at: ended_at,\n      last_message: messages.last&.content\n    }\n  end\n\n  def update_totals!\n    total_tokens = messages.sum(\"COALESCE(prompt_tokens, 0) + COALESCE(completion_tokens, 0)\")\n    total_cost = messages.sum(\"COALESCE(cost, 0)\")\n\n    update!(\n      total_tokens: total_tokens,\n      total_cost: total_cost\n    )\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/fact.rb`:\n\n```rb\nclass Fact < ApplicationRecord\n  vectorsearch\n\n  after_save :upsert_to_vectorsearch\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/person.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Person < ApplicationRecord\n  vectorsearch\n\n  after_save :upsert_to_vectorsearch\n\n  validates :name, presence: true\n  validates :description, presence: true\n  validates :extracted_from_session, presence: true\n\n  scope :recent, -> { order(last_seen_at: :desc) }\n  scope :by_relationship, ->(relationship) { where(relationship: relationship) }\n  scope :seen_recently, -> { where(\"last_seen_at > ?\", 1.week.ago) }\n\n  # Associations with summaries and events via extracted_from_session\n  def related_summaries\n    Summary.where(\"metadata @> ?\", { conversation_ids: [ extracted_from_session ] }.to_json)\n  end\n\n  def related_events\n    Event.where(extracted_from_session: extracted_from_session)\n  end\n\n  def metadata_json\n    return {} if metadata.blank?\n    JSON.parse(metadata)\n  rescue JSON::ParserError\n    {}\n  end\n\n  def metadata_json=(hash)\n    self.metadata = hash.to_json\n  end\n\n  # Update last seen time when person is mentioned again\n  def update_last_seen!(session_id = nil)\n    update!(\n      last_seen_at: Time.current,\n      extracted_from_session: session_id || extracted_from_session\n    )\n  end\n\n  # Find or create person by name and update their information\n  def self.find_or_update_person(name:, description:, session_id:, relationship: nil, additional_metadata: {})\n    # First try exact name match\n    person = find_by(name: name)\n\n    if person\n      # Update existing person with new information\n      person.description = [ person.description, description ].compact.join(\" | \").truncate(1000)\n      person.relationship = relationship if relationship.present?\n      person.last_seen_at = Time.current\n      person.extracted_from_session = session_id\n\n      # Merge metadata\n      current_metadata = person.metadata_json\n      person.metadata_json = current_metadata.merge(additional_metadata)\n\n      person.save!\n    else\n      # Create new person\n      person = create!(\n        name: name,\n        description: description,\n        relationship: relationship,\n        last_seen_at: Time.current,\n        extracted_from_session: session_id,\n        metadata: additional_metadata.to_json\n      )\n    end\n\n    person\n  end\n\n  # Search content for embedding includes name and description\n  def vectorsearch_fields_content\n    \"#{name}: #{description}\"\n  end\n\n  private\n\n  def vectorsearch_fields\n    {\n      content: vectorsearch_fields_content\n    }\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/glitch_cube.rb`:\n\n```rb\n# frozen_string_literal: true\n\n# Configuration class for GlitchCube system\n# Provides centralized access to configuration values and utility methods\nclass GlitchCube\n  class << self\n    def config\n      Rails.application.configuration\n    end\n\n    def set_random_location\n      Services::Gps::GPSTrackingService.new.set_location\n    end\n\n    # Set current location for testing/spoofing (console use)\n    def set_current_location(lat:, lng:)\n      Services::Gps::GPSTrackingService.new.set_location(coords: \"#{lat}, #{lng}\")\n    end\n\n    def home_camp_coordinates\n      {}\n    end\n\n    def gps_spoofing_allowed?\n      return false unless Rails.env.development?\n\n      true\n    end\n\n    # Get home camp coordinates (default to center of Black Rock City)\n    def home_camp_coordinates\n      {\n        lat: 40.7864,\n        lng: -119.2065,\n        address: \"Center Camp Plaza\",\n        name: \"Glitch Cube Home Camp\"\n      }\n    end\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/application_record.rb`:\n\n```rb\nclass ApplicationRecord < ActiveRecord::Base\n  primary_abstract_class\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/landmark.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Landmark < ApplicationRecord\n  before_save :update_spatial_location\n\n  validates :name, presence: true\n  validates :latitude, presence: true, numericality: true\n  validates :longitude, presence: true, numericality: true\n  validates :landmark_type, presence: true\n\n  scope :active, -> { where(active: true) }\n  scope :by_type, ->(type) { where(landmark_type: type) }\n\n  scope :within_radius, lambda { |lat, lng, radius_km|\n    begin\n      lat = connection.quote(lat.to_f)\n      lng = connection.quote(lng.to_f)\n      point = \"ST_SetSRID(ST_MakePoint(#{lng}, #{lat}), 4326)\"\n      radius_meters = radius_km * 1000\n\n      if connection.adapter_name.downcase.include?(\"postgis\") ||\n         connection.execute(\"SELECT PostGIS_version()\").present?\n        where(\"ST_DWithin(location::geography, (#{point})::geography, ?)\", radius_meters)\n      else\n        radius_miles = radius_km * 0.621371\n        where(\n          \"((latitude - ?) * (latitude - ?) + (longitude - ?) * (longitude - ?)) <= ?\",\n          lat, lat, lng, lng, (radius_miles / 69.0)**2\n        )\n      end\n    rescue PG::UndefinedFunction, ActiveRecord::StatementInvalid\n      radius_miles = radius_km * 0.621371\n      where(\n        \"((latitude - ?) * (latitude - ?) + (longitude - ?) * (longitude - ?)) <= ?\",\n        lat, lat, lng, lng, (radius_miles / 69.0)**2\n      )\n    end\n  }\n\n  def self.the_man\n    where(name: \"The Man\").first\n  end\n\n  def self.the_temple\n    where(name: \"The Temple\").first\n  end\n\n  def coordinates\n    [ latitude.to_f, longitude.to_f ]\n  end\n\n  def lat\n    latitude.to_f\n  end\n\n  def lng\n    longitude.to_f\n  end\n\n  def distance_from(lat, lng)\n    if has_spatial_data?\n      sql = \"SELECT ST_Distance(location::geography, ST_Point(?, ?)::geography) as distance\n             FROM landmarks WHERE id = ?\"\n      result = self.class.connection.select_one(\n        self.class.sanitize_sql([ sql, lng.to_f, lat.to_f, id ])\n      )\n      result[\"distance\"].to_f / 1609.34\n    else\n      require \"geocoder\"\n      require \"geocoder/calculations\"\n      Geocoder.configure(units: :mi) unless Geocoder.config.units\n      Geocoder::Calculations.distance_between([ lat, lng ], coordinates, units: :mi)\n    end\n  rescue StandardError\n    require \"geocoder\"\n    require \"geocoder/calculations\"\n    Geocoder.configure(units: :mi) unless Geocoder.config.units\n    Geocoder::Calculations.distance_between([ lat, lng ], coordinates, units: :mi)\n  end\n\n  def within_radius?(lat, lng, radius_miles = nil)\n    radius_miles ||= (radius_meters || 30) / 1609.34\n    distance_from(lat, lng) <= radius_miles\n  end\n\n  def spatial_data?\n    respond_to?(:location) && location.present? &&\n      self.class.connection.adapter_name.downcase.include?(\"postgis\")\n  rescue StandardError\n    false\n  end\n\n  def self.near_location(lat, lng, radius_miles = 0.1)\n    radius_km = radius_miles * 1.609344\n    within_radius(lat, lng, radius_km).active\n  end\n\n  def self.center_camp\n    where(name: \"Center Camp\", landmark_type: \"gathering\").first ||\n      where(name: \"Center Camp\").first\n  end\n\n  def self.the_man\n    where(name: \"The Man\", landmark_type: \"center\").first ||\n      where(name: \"The Man\").first\n  end\n\n  def self.the_temple\n    where(name: \"The Temple\", landmark_type: \"sacred\").first ||\n      where(name: \"The Temple\").first\n  end\n\n  def self.by_distance_from(lat, lng)\n    if postgis_available?\n      lat_safe = connection.quote(lat.to_f)\n      lng_safe = connection.quote(lng.to_f)\n      point = \"ST_SetSRID(ST_MakePoint(#{lng_safe}, #{lat_safe}), 4326)\"\n      active.order(\n        Arel.sql(\"ST_Distance(location::geography, (#{point})::geography)\")\n      )\n    else\n      active.sort_by { |landmark| landmark.distance_from(lat, lng) }\n    end\n  end\n\n  scope :nearest, lambda { |*args|\n    if args.first.is_a?(Hash)\n      opts = args.first\n      lng = opts[:lng] || opts[:longitude]\n      lat = opts[:lat] || opts[:latitude]\n      limit = opts[:limit] || 10\n    else\n      lng, lat, limit = args\n      limit ||= 10\n    end\n\n    raise ArgumentError, \"Must provide lng and lat coordinates\" unless lng && lat\n\n    if postgis_available? && column_names.include?(\"location\")\n      point_sql = sanitize_sql_array(\n        [ \"ST_SetSRID(ST_MakePoint(?, ?), 4326)::geography\", lng.to_f, lat.to_f ]\n      )\n\n      active\n        .select(\"#{table_name}.*, ST_Distance(#{table_name}.location::geography, #{point_sql}) AS distance_meters\")\n        .order(Arel.sql(\"#{table_name}.location::geography <-> #{point_sql}\"))\n        .limit(limit)\n    else\n      by_distance_from(lat, lng).limit(limit)\n    end\n  }\n\n  scope :within_meters, lambda { |lng, lat, meters|\n    raise ArgumentError, \"Must provide lng, lat, and meters\" unless lng && lat && meters\n\n    if postgis_available? && column_names.include?(\"location\")\n      point_sql = sanitize_sql_array(\n        [ \"ST_SetSRID(ST_MakePoint(?, ?), 4326)::geography\", lng.to_f, lat.to_f ]\n      )\n\n      where(\"ST_DWithin(#{table_name}.location::geography, #{point_sql}, ?)\", meters.to_f)\n    else\n      radius_miles = meters.to_f / 1609.34\n      near_location(lat, lng, radius_miles)\n    end\n  }\n\n  scope :within_bounds, lambda { |sw_lng, sw_lat, ne_lng, ne_lat|\n    if postgis_available? && column_names.include?(\"location\")\n      box = \"POLYGON((#{sw_lng} #{sw_lat}, #{sw_lng} #{ne_lat}, #{ne_lng} #{ne_lat}, #{ne_lng} #{sw_lat}, #{sw_lng} #{sw_lat}))\"\n      where(\"ST_Within(location, ST_GeomFromText('SRID=4326;#{box}'))\")\n    else\n      where(latitude: sw_lat..ne_lat, longitude: sw_lng..ne_lng)\n    end\n  }\n\n  def self.postgis_available?\n    @postgis_available ||= begin\n      connection.execute(\"SELECT PostGIS_version()\").present?\n    rescue StandardError\n      false\n    end\n  end\n\n  def self.import_from_gis_data(gis_data_path = \"data/gis\")\n    import_from_landmarks_json(File.join(gis_data_path, \"burning_man_landmarks.json\"))\n    import_from_toilets_geojson(File.join(gis_data_path, \"toilets.geojson\"))\n    import_from_plazas_geojson(File.join(gis_data_path, \"plazas.geojson\"))\n    import_from_cpns_geojson(File.join(gis_data_path, \"cpns.geojson\"))\n\n    Street.import_from_geojson(File.join(gis_data_path, \"street_lines.geojson\")) if defined?(Street)\n\n    return unless defined?(Boundary)\n\n    Boundary.import_from_geojson(File.join(gis_data_path, \"city_blocks.geojson\"), \"city_block\")\n    Boundary.import_from_geojson(File.join(gis_data_path, \"trash_fence.geojson\"), \"fence\")\n  end\n\n  private\n\n  def self.import_from_landmarks_json(file_path)\n    return unless File.exist?(file_path)\n\n    data = JSON.parse(File.read(file_path))\n    data[\"landmarks\"].each do |landmark_data|\n      landmark = find_or_initialize_by(\n        name: landmark_data[\"name\"],\n        landmark_type: landmark_data[\"type\"]\n      )\n\n      landmark.assign_attributes(\n        latitude: landmark_data[\"lat\"],\n        longitude: landmark_data[\"lng\"],\n        icon: landmark_data[\"icon\"],\n        radius_meters: landmark_data[\"radius\"] || 30,\n        description: landmark_data[\"context\"],\n        properties: {\n          alias: landmark_data[\"alias\"],\n          cpn_type: landmark_data[\"cpn_type\"]\n        }.compact,\n        active: true\n      )\n\n      landmark.save! if landmark.changed?\n    end\n  end\n\n  def self.import_from_toilets_geojson(file_path)\n    return unless File.exist?(file_path)\n\n    data = JSON.parse(File.read(file_path))\n    data[\"features\"].each_with_index do |feature, index|\n      coordinates = feature[\"geometry\"][\"coordinates\"][0]\n      centroid = calculate_polygon_centroid(coordinates)\n\n      landmark = find_or_initialize_by(\n        name: \"Toilet #{index + 1}\",\n        landmark_type: \"toilet\"\n      )\n\n      landmark.assign_attributes(\n        latitude: centroid[1],\n        longitude: centroid[0],\n        icon: \"üöª\",\n        radius_meters: 20,\n        description: \"Portable toilet facility\",\n        properties: {\n          fid: feature[\"id\"],\n          ref: feature[\"properties\"][\"ref\"]\n        },\n        active: true\n      )\n\n      landmark.save! if landmark.changed?\n    end\n  end\n\n  def self.import_from_plazas_geojson(file_path)\n    return unless File.exist?(file_path)\n\n    data = JSON.parse(File.read(file_path))\n    data[\"features\"].each do |feature|\n      coordinates = feature[\"geometry\"][\"coordinates\"][0]\n      centroid = calculate_polygon_centroid(coordinates)\n\n      landmark = find_or_initialize_by(\n        name: feature[\"properties\"][\"Name\"],\n        landmark_type: \"plaza\"\n      )\n\n      landmark.assign_attributes(\n        latitude: centroid[1],\n        longitude: centroid[0],\n        icon: \"üèõÔ∏è\",\n        radius_meters: 50,\n        description: \"Community plaza and gathering space\",\n        properties: {\n          fid: feature[\"id\"]\n        },\n        active: true\n      )\n\n      landmark.save! if landmark.changed?\n    end\n  end\n\n  def self.import_from_cpns_geojson(file_path)\n    return unless File.exist?(file_path)\n\n    data = JSON.parse(File.read(file_path))\n    data[\"features\"].each do |feature|\n      name = feature[\"properties\"][\"NAME\"]\n      cpn_type = feature[\"properties\"][\"TYPE\"] || \"CPN\"\n\n      landmark = find_or_initialize_by(\n        name: name,\n        landmark_type: \"cpn\"\n      )\n\n      landmark.assign_attributes(\n        latitude: feature[\"geometry\"][\"coordinates\"][1],\n        longitude: feature[\"geometry\"][\"coordinates\"][0],\n        icon: \"üìç\",\n        radius_meters: 30,\n        description: \"Center Placement: #{name}\",\n        properties: {\n          fid: feature[\"id\"],\n          cpn_type: cpn_type,\n          alias: feature[\"properties\"][\"ALIAS1\"]\n        }.compact,\n        active: true\n      )\n\n      landmark.save! if landmark.changed?\n    end\n  end\n\n  def self.calculate_polygon_centroid(coordinates)\n    lat_sum = coordinates.sum { |coord| coord[1] }\n    lng_sum = coordinates.sum { |coord| coord[0] }\n    count = coordinates.length\n\n    [ lng_sum / count, lat_sum / count ]\n  end\n\n  private_class_method :import_from_landmarks_json, :import_from_toilets_geojson,\n                       :import_from_plazas_geojson, :import_from_cpns_geojson,\n                       :calculate_polygon_centroid\n\n  def update_spatial_location\n    return unless latitude.present? && longitude.present?\n    return unless respond_to?(:location=)\n\n    begin\n      if self.class.postgis_available?\n        self.location = \"SRID=4326;POINT(#{longitude} #{latitude})\"\n      end\n    rescue StandardError => e\n      Rails.logger&.warn(\"Failed to update spatial location: #{e.message}\")\n    end\n  end\n\n  def has_spatial_data?\n    spatial_data?\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/event.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Event < ApplicationRecord\n  vectorsearch\n\n  after_save :upsert_to_vectorsearch\n\n  IMPORTANCE_RANGE = (1..10).freeze\n\n  scope :for_address, -> { where(\"address ILIKE ?\", \"%?%\") }\n  scope :upcoming, -> { where(\"event_time > ?\", Time.current) }\n  scope :past, -> { where(\"event_time <= ?\", Time.current) }\n  scope :within_hours, ->(hours) { where(event_time: Time.current..(Time.current + hours.hours)) }\n  scope :by_location, ->(location) { where(location: location) }\n  scope :high_importance, -> { where(importance: 7..10) }\n  scope :medium_importance, -> { where(importance: 4..6) }\n  scope :low_importance, -> { where(importance: 1..3) }\n  scope :recent, -> { order(event_time: :asc) }\n\n  def metadata_json\n    return {} if metadata.blank?\n    JSON.parse(metadata)\n  rescue JSON::ParserError\n    {}\n  end\n\n  def metadata_json=(hash)\n    self.metadata = hash.to_json\n  end\n\n  def upcoming?\n    return false unless event_time\n    event_time > Time.current\n  end\n\n  def high_importance?\n    importance >= 7\n  end\n\n  def time_until_event\n    return nil unless event_time && upcoming?\n    event_time - Time.current\n  end\n\n  def hours_until_event\n    return nil unless upcoming?\n    (time_until_event / 1.hour).round(1)\n  end\n\n  def formatted_time\n    return \"No time set\" unless event_time\n    event_time.strftime(\"%m/%d at %I:%M %p\")\n  end\n\n  # Search content includes title, description, and location\n  def vectorsearch_fields_content\n    content_parts = [ title, description ]\n    content_parts << \"at #{location}\" if location.present?\n    content_parts << \"on #{formatted_time}\" if event_time.present?\n    content_parts.join(\" \")\n  end\n\n  private\n\n  def vectorsearch_fields\n    {\n      content: vectorsearch_fields_content\n    }\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/concerns/ai_structured_response.rb`:\n\n```rb\n# app/models/concerns/ai_structured_response.rb\nmodule AiStructuredResponse\n  extend ActiveSupport::Concern\n\n  included do\n    include ActiveModel::Model\n    include ActiveModel::Attributes\n    include ActiveModel::Validations\n    include ActiveModel::Serialization\n\n    class_attribute :_ai_schema\n\n    # Store the raw response and metadata\n    attr_accessor :_raw_response, :_ai_metadata, :_confidence_score\n  end\n\n  class_methods do\n    # Define the schema for this response type\n    def ai_schema(name = nil, &block)\n      schema_name = name || self.name.underscore\n      self._ai_schema = OpenRouter::Schema.define(schema_name, &block)\n    end\n\n    # Generate a response using AI with auto-healing enabled\n    def ai_generate(prompt, model: nil, **options)\n      client = ai_client\n\n      # Always use our schema and force structured output with auto-healing\n      response = client.complete(\n        prepare_messages(prompt, options),\n        model: model || default_model,\n        response_format: _ai_schema,\n        force_structured_output: true, # Always force structured format\n        **options.except(:messages, :prompt, :model)\n      )\n\n      from_ai_response(response)\n    end\n\n    # Create instance from OpenRouter response\n    def from_ai_response(response)\n      instance = new\n      instance._raw_response = response\n      instance._ai_metadata = extract_metadata(response)\n\n      # Always try to parse structured output with auto-healing\n      begin\n        # Auto-healing is enabled by default in your gem\n        data = response.structured_output(auto_heal: true)\n        populate_from_data(instance, data) if data\n        instance._confidence_score = :high\n      rescue OpenRouter::StructuredOutputError => e\n        Rails.logger.error \"AI structured output failed after healing: #{e.message}\"\n        # Store the error for debugging\n        instance._ai_metadata[:parsing_error] = e.message\n        instance._confidence_score = :failed\n      end\n\n      instance\n    end\n\n    private\n\n    def ai_client\n      @ai_client ||= begin\n        # Build on the existing OpenRouter client configuration\n        base_client = OpenRouter.client\n\n        # Create a new client with enhanced configuration for structured responses\n        OpenRouter::Client.new(\n          api_key: base_client.api_key,\n          app_name: base_client.app_name,\n          site_url: base_client.site_url\n        ) do |config|\n          config.auto_heal_responses = true\n          config.healer_model = \"openai/gpt-4o-mini\"\n          config.max_heal_attempts = 3\n        end\n      end\n    end\n\n    def default_model\n      # Set a reasonable default model\n      Rails.configuration.default_ai_model\n    end\n\n    def prepare_messages(prompt, options)\n      messages = case prompt\n      when String\n                   [ { role: \"user\", content: prompt } ]\n      when Array\n                   prompt\n      when Hash\n                   [ prompt ]\n      else\n                   raise ArgumentError, \"Prompt must be String, Array, or Hash\"\n      end\n\n      # Add system message if provided in options\n      if options[:system_message]\n        messages.unshift({ role: \"system\", content: options[:system_message] })\n      end\n\n      messages\n    end\n\n    def populate_from_data(instance, data)\n      data.each do |key, value|\n        setter_method = \"#{key}=\"\n        if instance.respond_to?(setter_method)\n          instance.public_send(setter_method, value)\n        else\n          # Store unknown fields in metadata for debugging\n          instance._ai_metadata ||= {}\n          instance._ai_metadata[:unknown_fields] ||= {}\n          instance._ai_metadata[:unknown_fields][key] = value\n        end\n      end\n    end\n\n    def extract_metadata(response)\n      {\n        model_used: response.model,\n        usage: response.usage,\n        response_id: response.id,\n        created_at: Time.at(response.created),\n        has_tool_calls: response.has_tool_calls?,\n        tool_calls_count: response.tool_calls.size,\n        raw_content: response.content,\n        forced_extraction: response.instance_variable_get(:@forced_extraction)\n      }\n    end\n  end\n\n  # Instance methods\n  def ai_metadata\n    @_ai_metadata || {}\n  end\n\n  def ai_confidence\n    @_confidence_score || :unknown\n  end\n\n  def ai_successful?\n    ai_confidence == :high\n  end\n\n  def ai_failed?\n    ai_confidence == :failed\n  end\n\n  def regenerate(model: nil, **options)\n    raise \"Cannot regenerate without original prompt\" unless ai_metadata[:original_prompt]\n\n    self.class.ai_generate(ai_metadata[:original_prompt], model: model, **options)\n  end\n\n  def to_hash\n    attributes.except(\"_raw_response\", \"_ai_metadata\", \"_confidence_score\")\n  end\n\n  def as_json(options = {})\n    hash = to_hash\n    if options[:include_metadata]\n      hash[:_metadata] = {\n        confidence: ai_confidence,\n        model_used: ai_metadata[:model_used],\n        usage: ai_metadata[:usage],\n        forced_extraction: ai_metadata[:forced_extraction]\n      }\n    end\n    hash\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/models/boundary.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Boundary < ApplicationRecord\n  validates :name, presence: true\n  validates :boundary_type, presence: true\n  validates :geom, presence: true\n\n  scope :active, -> { where(active: true) }\n  scope :by_type, ->(type) { where(boundary_type: type) }\n\n  scope :within_viewport, lambda { |sw_lng, sw_lat, ne_lng, ne_lat|\n    where(\"geom && ST_MakeEnvelope(?, ?, ?, ?, 4326)\", sw_lng, sw_lat, ne_lng, ne_lat)\n  }\n\n  def coordinates\n    return [] unless geom.present?\n\n    result = self.class.connection.execute(\n      \"SELECT ST_AsGeoJSON(geom) as geojson FROM boundaries WHERE id = #{id}\"\n    ).first\n\n    return [] unless result && result[\"geojson\"]\n\n    geojson = JSON.parse(result[\"geojson\"])\n    geojson[\"coordinates\"] || []\n  rescue StandardError\n    []\n  end\n\n  def contains_point?(lat, lng)\n    return false unless geom.present?\n\n    self.class\n        .where(id: id)\n        .where(\"ST_Contains(geom, ST_SetSRID(ST_Point(?, ?), 4326))\", lng.to_f, lat.to_f)\n        .exists?\n  rescue StandardError\n    false\n  end\n\n  def self.trash_fence\n    fence = by_type(\"fence\").first\n    if fence && (fence.name.blank? || fence.name.match?(/^Fence \\d+$/))\n      fence.update_column(:name, \"Trash Fence Perimeter\")\n    end\n    fence\n  end\n\n  def self.within_fence?(lat, lng)\n    trash_fence&.contains_point?(lat, lng) || false\n  end\n\n  def self.cube_within_fence?(lat, lng)\n    where(boundary_type: \"fence\")\n      .where(\"ST_Contains(geom, ST_SetSRID(ST_Point(?, ?), 4326))\", lng, lat)\n      .exists?\n  end\n\n  def self.point_in_boundary_type?(lat, lng, boundary_type)\n    where(boundary_type: boundary_type)\n      .where(\"ST_Contains(geom, ST_SetSRID(ST_Point(?, ?), 4326))\", lng, lat)\n      .exists?\n  end\n\n  def self.in_city?(lat, lng)\n    return true if point_in_boundary_type?(lat, lng, \"city_block\")\n\n    Landmark.where(landmark_type: \"plaza\")\n            .within_meters(lng, lat, 35)\n            .exists?\n  end\n\n  def self.containing_city_block(lat, lng)\n    where(boundary_type: \"city_block\")\n      .where(\"ST_Contains(geom, ST_SetSRID(ST_Point(?, ?), 4326))\", lng, lat)\n      .first\n  end\n\n  scope :nearest, lambda { |*args|\n    if args.first.is_a?(Hash)\n      opts = args.first\n      lng = opts[:lng] || opts[:longitude]\n      lat = opts[:lat] || opts[:latitude]\n      limit = opts[:limit] || 10\n    else\n      lng, lat, limit = args\n      limit ||= 10\n    end\n\n    raise ArgumentError, \"Must provide lng and lat coordinates\" unless lng && lat\n\n    point_sql = sanitize_sql_array(\n      [ \"ST_SetSRID(ST_MakePoint(?, ?), 4326)::geography\", lng.to_f, lat.to_f ]\n    )\n\n    active\n      .select(\"#{table_name}.*, ST_Distance(geom::geography, #{point_sql}) AS distance_meters\")\n      .order(Arel.sql(\"geom::geography <-> #{point_sql}\"))\n      .limit(limit)\n  }\n\n  scope :containing_point, lambda { |lng, lat|\n    raise ArgumentError, \"Must provide lng and lat coordinates\" unless lng && lat\n\n    point_sql = sanitize_sql_array(\n      [ \"ST_SetSRID(ST_MakePoint(?, ?), 4326)\", lng.to_f, lat.to_f ]\n    )\n\n    where(\"ST_Contains(geom, #{point_sql})\")\n  }\n\n  scope :within_meters, lambda { |lng, lat, meters|\n    raise ArgumentError, \"Must provide lng, lat, and meters\" unless lng && lat && meters\n\n    point_sql = sanitize_sql_array(\n      [ \"ST_SetSRID(ST_MakePoint(?, ?), 4326)::geography\", lng.to_f, lat.to_f ]\n    )\n\n    where(\"ST_DWithin(geom::geography, #{point_sql}, ?)\", meters.to_f)\n  }\n\n  def self.import_from_geojson(file_path, default_type = nil)\n    return unless File.exist?(file_path)\n\n    data = JSON.parse(File.read(file_path))\n    imported_count = 0\n\n    data[\"features\"].each_with_index do |feature, index|\n      props = feature[\"properties\"] || {}\n\n      boundary_type = props[\"type\"] || props[\"boundary_type\"] || default_type\n      boundary_type ||= case file_path\n      when /city_blocks/ then \"city_block\"\n      when /trash_fence/ then \"fence\"\n      else \"boundary\"\n      end\n\n      name = props[\"name\"] || props[\"NAME\"]\n      if boundary_type == \"city_block\"\n        block_id = props[\"FID\"] || props[\"Id\"] || index\n        name ||= \"City Block #{block_id}\"\n      end\n      name ||= \"#{boundary_type.humanize} #{index}\"\n\n      boundary = find_or_initialize_by(\n        name: name,\n        boundary_type: boundary_type\n      )\n\n      boundary.assign_attributes(\n        description: props[\"description\"] || \"#{boundary_type.humanize} area\",\n        properties: {\n          fid: feature[\"id\"],\n          original_properties: props,\n          geometry_type: feature[\"geometry\"][\"type\"]\n        },\n        active: true\n      )\n\n      if boundary.save(validate: false)\n        geojson = feature[\"geometry\"].to_json\n        connection.execute(sanitize_sql_array([\n                                                \"UPDATE boundaries SET geom = ST_SetSRID(ST_GeomFromGeoJSON(?), 4326) WHERE id = ?\",\n                                                geojson, boundary.id\n                                              ]))\n        imported_count += 1\n      else\n        puts \"   ‚ùå Failed to save boundary #{boundary.name}: #{boundary.errors.full_messages.join(', ')}\"\n      end\n    end\n\n    puts \"‚úÖ Imported #{imported_count} boundaries from #{File.basename(file_path)}\"\n    imported_count\n  end\n\n  def self.import_from_city_blocks(file_path)\n    import_from_geojson(file_path, \"city_block\")\n  end\nend\n\n```",
  "token_count": 0
}
