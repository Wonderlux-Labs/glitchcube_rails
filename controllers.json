{
  "directory_name": "controllers",
  "files": [
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/application_controller.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/gps_controller.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/health_controller.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/admin/base_controller.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/admin/conversations_controller.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/admin/memories_controller.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/admin/world_state_controller.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/admin/dashboard_controller.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/home_assistant_controller.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/api/v1/conversation_controller.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/api/v1/base_controller.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/api/v1/summaries_controller.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/api/v1/gps_controller.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/api/v1/gis_controller.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/api/base_controller.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/performance_controller.rb",
    "/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/performance_mode_controller.rb"
  ],
  "model_info": "ChatGPT models, text-embedding-ada-002",
  "prompt": "Project Path: controllers\n\nSource Tree:\n\n```\ncontrollers\n‚îú‚îÄ‚îÄ application_controller.rb\n‚îú‚îÄ‚îÄ gps_controller.rb\n‚îú‚îÄ‚îÄ health_controller.rb\n‚îú‚îÄ‚îÄ admin\n‚îÇ   ‚îú‚îÄ‚îÄ base_controller.rb\n‚îÇ   ‚îú‚îÄ‚îÄ conversations_controller.rb\n‚îÇ   ‚îú‚îÄ‚îÄ memories_controller.rb\n‚îÇ   ‚îú‚îÄ‚îÄ world_state_controller.rb\n‚îÇ   ‚îî‚îÄ‚îÄ dashboard_controller.rb\n‚îú‚îÄ‚îÄ home_assistant_controller.rb\n‚îú‚îÄ‚îÄ api\n‚îÇ   ‚îú‚îÄ‚îÄ v1\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ conversation_controller.rb\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base_controller.rb\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ summaries_controller.rb\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gps\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gps_controller.rb\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ gis_controller.rb\n‚îÇ   ‚îî‚îÄ‚îÄ base_controller.rb\n‚îú‚îÄ‚îÄ concerns\n‚îú‚îÄ‚îÄ performance_controller.rb\n‚îî‚îÄ‚îÄ performance_mode_controller.rb\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/application_controller.rb`:\n\n```rb\nclass ApplicationController < ActionController::Base\n  # Only allow modern browsers supporting webp images, web push, badges, import maps, CSS nesting, and CSS :has.\n  allow_browser versions: :modern\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/gps_controller.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass GpsController < ApplicationController\n  def map\n    # Serve the GPS map view without layout\n    render :map, layout: false\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/health_controller.rb`:\n\n```rb\n# app/controllers/health_controller.rb\nclass HealthController < ApplicationController\n  def show\n    health_data = {\n      status: overall_status,\n      timestamp: Time.current.iso8601,\n      version: \"1.0.0\",\n      uptime: uptime_seconds,\n      services: service_health,\n      host: request.host,\n      port: request.port\n    }\n\n    render json: health_data\n  end\n\n  private\n\n  def overall_status\n    # Health check - all services must be healthy (allow migration_needed and not_configured as OK)\n    statuses = service_health.values\n\n    # If any service is truly unhealthy, we're degraded\n    return \"degraded\" if statuses.include?(\"unhealthy\")\n\n    # If migrations needed, show that specifically\n    return \"migration_needed\" if statuses.include?(\"migration_needed\")\n\n    # If Home Assistant not configured, that's OK for basic operation\n    healthy_or_ok = [ \"healthy\", \"not_configured\" ]\n    statuses.all? { |status| healthy_or_ok.include?(status) } ? \"healthy\" : \"degraded\"\n  end\n\n  def service_health\n    service_string = Rails.cache.fetch(\"service_string\", expires_in: 5.minutes) do\n      services = {}\n\n      # Database health\n      services[:database] = check_database_health\n\n      # Migration status\n      services[:migrations] = check_migration_health\n\n      # Home Assistant connectivity\n      services[:home_assistant] = check_home_assistant_health\n\n      # OpenRouter/LLM service\n      services[:llm] = check_llm_health\n\n      services.to_json\n    end\n    JSON.parse(service_string).with_indifferent_access\n  end\n\n  def check_database_health\n    ActiveRecord::Base.connection.execute(\"SELECT 1\")\n    \"healthy\"\n  rescue StandardError\n    \"unhealthy\"\n  end\n\n  def check_migration_health\n    # Check if there are pending migrations\n    ActiveRecord::Migration.check_all_pending!\n    \"healthy\" # If no exception, migrations are up to date\n  rescue ActiveRecord::PendingMigrationError\n    \"migration_needed\"\n  rescue StandardError\n    \"unhealthy\"\n  end\n\n  def check_home_assistant_health\n    # Quick check if HASS is configured and reachable\n    return \"not_configured\" unless Rails.configuration.home_assistant_url\n\n    HomeAssistantService.instance.available?\n    \"healthy\"\n  rescue StandardError\n    \"unhealthy\"\n  end\n\n  def check_llm_health\n    # Simple backend health check - just return healthy\n    \"healthy\"\n  rescue StandardError\n    \"unhealthy\"\n  end\n\n  def uptime_seconds\n    # Simple uptime - just return a reasonable number\n    # In a real app you'd track actual boot time\n    3600  # 1 hour placeholder\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/admin/base_controller.rb`:\n\n```rb\n# app/controllers/admin/base_controller.rb\n\nclass Admin::BaseController < ApplicationController\n  # Base controller for admin dashboard\n  # Add any admin-wide authentication or configuration here\n\n  before_action :set_admin_context\n\n  private\n\n  def set_admin_context\n    @admin_nav_items = [\n      { name: \"Dashboard\", path: admin_root_path, icon: \"üè†\" },\n      { name: \"Conversations\", path: admin_conversations_path, icon: \"üí¨\" },\n      { name: \"Memories\", path: admin_memories_path, icon: \"üß†\" },\n      { name: \"World State\", path: admin_world_state_path, icon: \"üåç\" },\n      { name: \"Prompts\", path: admin_prompts_path, icon: \"ü§ñ\" },\n      { name: \"Jobs\", path: \"/jobs\", icon: \"‚öôÔ∏è\" },\n      { name: \"System\", path: admin_system_path, icon: \"üìä\" }\n    ]\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/admin/conversations_controller.rb`:\n\n```rb\n# app/controllers/admin/conversations_controller.rb\n\nclass Admin::ConversationsController < Admin::BaseController\n  def index\n    @conversations = Conversation.includes(:conversation_logs, :conversation_memories)\n                                .order(created_at: :desc)\n                                .limit(50)\n\n    # Simple filters\n    if params[:status] == \"active\"\n      @conversations = @conversations.active\n    elsif params[:status] == \"finished\"\n      @conversations = @conversations.finished\n    end\n\n    if params[:persona].present?\n      @conversations = @conversations.by_persona(params[:persona])\n    end\n  end\n\n  def show\n    @conversation = Conversation.find(params[:id])\n    @logs = @conversation.conversation_logs.chronological\n    @memories = @conversation.conversation_memories.recent\n    @tools_used = extract_tools_from_logs(@logs)\n  end\n\n  def timeline\n    @conversation = Conversation.find(params[:id])\n    @timeline_events = build_timeline(@conversation)\n    render json: @timeline_events\n  end\n\n  def tools\n    @conversation = Conversation.find(params[:id])\n    @tools = extract_detailed_tools(@conversation)\n    render json: @tools\n  end\n\n  private\n\n  def extract_tools_from_logs(logs)\n    tools = []\n    logs.each do |log|\n      tool_results = log.tool_results_json\n      if tool_results.present?\n        tools << {\n          log_id: log.id,\n          timestamp: log.created_at,\n          tools: tool_results\n        }\n      end\n    end\n    tools\n  end\n\n  def build_timeline(conversation)\n    events = []\n\n    # Conversation start\n    events << {\n      type: \"conversation_start\",\n      timestamp: conversation.started_at,\n      title: \"Conversation Started\",\n      details: \"Persona: #{conversation.persona}\"\n    }\n\n    # Each log entry\n    conversation.conversation_logs.chronological.each do |log|\n      events << {\n        type: \"message_exchange\",\n        timestamp: log.created_at,\n        title: \"Message Exchange\",\n        user_message: log.user_message.truncate(100),\n        ai_response: log.ai_response.truncate(100),\n        tools_used: log.tool_results_json.present?\n      }\n    end\n\n    # Memories created\n    conversation.conversation_memories.each do |memory|\n      events << {\n        type: \"memory_created\",\n        timestamp: memory.created_at,\n        title: \"Memory Created\",\n        details: \"#{memory.memory_type}: #{memory.summary.truncate(60)}\"\n      }\n    end\n\n    # Conversation end\n    if conversation.ended_at\n      events << {\n        type: \"conversation_end\",\n        timestamp: conversation.ended_at,\n        title: \"Conversation Ended\",\n        details: \"Duration: #{conversation.duration&.round(2)}s\"\n      }\n    end\n\n    events.sort_by { |e| e[:timestamp] }\n  end\n\n  def extract_detailed_tools(conversation)\n    all_tools = []\n    conversation.conversation_logs.each do |log|\n      tool_results = log.tool_results_json\n      if tool_results.present?\n        tool_results.each do |tool_name, result|\n          all_tools << {\n            log_id: log.id,\n            timestamp: log.created_at,\n            tool_name: tool_name,\n            result: result,\n            user_context: log.user_message.truncate(50)\n          }\n        end\n      end\n    end\n    all_tools\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/admin/memories_controller.rb`:\n\n```rb\n# app/controllers/admin/memories_controller.rb\n\nclass Admin::MemoriesController < Admin::BaseController\n  def index\n    @memories = ConversationMemory.includes(:conversation)\n                                 .order(created_at: :desc)\n                                 .limit(100)\n\n    if params[:type].present?\n      @memories = @memories.by_type(params[:type])\n    end\n\n    if params[:importance].present?\n      @memories = @memories.by_importance(params[:importance])\n    end\n\n    @memory_types = ConversationMemory::MEMORY_TYPES\n    @type_counts = ConversationMemory.group(:memory_type).count\n  end\n\n  def show\n    @memory = ConversationMemory.find(params[:id])\n    @conversation = @memory.conversation\n  end\n\n  def search\n    query = params[:q]\n    if query.present?\n      @memories = ConversationMemory.where(\"summary ILIKE ?\", \"%#{query}%\")\n                                   .order(created_at: :desc)\n                                   .limit(50)\n    else\n      @memories = ConversationMemory.none\n    end\n\n    render :index\n  end\n\n  def by_type\n    @type = params[:type]\n    @memories = ConversationMemory.by_type(@type).recent.limit(50)\n    render :index\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/admin/world_state_controller.rb`:\n\n```rb\n# app/controllers/admin/world_state_controller.rb\n\nclass Admin::WorldStateController < Admin::BaseController\n  def index\n    @world_state_sensor = get_world_state_sensor\n    @weather_sensors = get_weather_sensors\n    @all_sensors = get_all_sensors\n    @available_services = get_available_world_state_services\n  end\n\n  def history\n    # This would show historical changes to world state\n    render json: { message: \"History tracking not yet implemented\" }\n  end\n\n  def trigger\n    service_name = params[:service]\n\n    begin\n      service_class = \"WorldStateUpdaters::#{service_name}\".constantize\n      result = service_class.call\n\n      flash[:notice] = \"‚úÖ #{service_name} executed successfully\"\n      if result.is_a?(String)\n        flash[:notice] += \": #{result.truncate(100)}\"\n      end\n    rescue NameError\n      flash[:error] = \"‚ùå Service '#{service_name}' not found\"\n    rescue StandardError => e\n      flash[:error] = \"‚ùå Service failed: #{e.message}\"\n    end\n\n    redirect_to admin_world_state_path\n  end\n\n  private\n\n  def get_world_state_sensor\n    HomeAssistantService.entity(\"sensor.world_state\")\n  rescue StandardError => e\n    Rails.logger.error \"Failed to get world state sensor: #{e.message}\"\n    nil\n  end\n\n  def get_weather_sensors\n    weather_patterns = [ \"temperature\", \"humidity\", \"pressure\", \"weather\", \"wind\", \"rain\" ]\n    sensors = HomeAssistantService.entities_by_domain(\"sensor\")\n\n    sensors.select do |sensor|\n      entity_id = sensor[\"entity_id\"].downcase\n      weather_patterns.any? { |pattern| entity_id.include?(pattern) }\n    end.first(10)  # Limit to first 10\n  rescue StandardError => e\n    Rails.logger.error \"Failed to get weather sensors: #{e.message}\"\n    []\n  end\n\n  def get_all_sensors\n    HomeAssistantService.entities_by_domain(\"sensor\").count\n  rescue StandardError\n    0\n  end\n\n  def get_available_world_state_services\n    # Scan for available world state services\n    services = []\n\n    service_dir = Rails.root.join(\"app\", \"services\", \"world_state_updaters\")\n    if Dir.exist?(service_dir)\n      Dir.glob(\"#{service_dir}/*.rb\").each do |file|\n        filename = File.basename(file, \".rb\")\n        service_name = filename.camelize\n        services << {\n          name: service_name,\n          filename: filename,\n          description: extract_service_description(file)\n        }\n      end\n    end\n\n    services\n  end\n\n  def extract_service_description(file_path)\n    # Simple description extraction from comments\n    File.readlines(file_path).first(5).each do |line|\n      if line.strip.start_with?(\"#\") && !line.include?(\"app/services\")\n        return line.gsub(\"#\", \"\").strip\n      end\n    end\n    \"No description available\"\n  rescue StandardError\n    \"Description unavailable\"\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/admin/dashboard_controller.rb`:\n\n```rb\n# app/controllers/admin/dashboard_controller.rb\n\nclass Admin::DashboardController < Admin::BaseController\n  def index\n    @stats = {\n      conversations: conversation_stats,\n      memories: memory_stats,\n      world_state: world_state_stats,\n      jobs: job_stats,\n      system: system_stats\n    }\n\n    @recent_activity = recent_activity_feed\n  end\n\n  private\n\n  def conversation_stats\n    {\n      total: Conversation.count,\n      active: Conversation.active.count,\n      finished_today: Conversation.finished.where(ended_at: 1.day.ago..Time.current).count,\n      avg_duration: Conversation.finished.average(:duration)&.round(2) || 0\n    }\n  end\n\n  def memory_stats\n    {\n      total: ConversationMemory.count,\n      by_type: ConversationMemory.group(:memory_type).count,\n      high_importance: ConversationMemory.high_importance.count,\n      recent: ConversationMemory.where(created_at: 1.day.ago..Time.current).count\n    }\n  end\n\n  def world_state_stats\n    begin\n      world_state = HomeAssistantService.entity(\"sensor.world_state\")\n      {\n        status: world_state ? \"active\" : \"inactive\",\n        last_weather_update: world_state&.dig(\"attributes\", \"weather_updated_at\"),\n        total_sensors: HomeAssistantService.entities_by_domain(\"sensor\").count\n      }\n    rescue StandardError => e\n      {\n        status: \"error\",\n        error: e.message,\n        total_sensors: 0\n      }\n    end\n  end\n\n  def job_stats\n    # Basic stats - Mission Control provides detailed job info\n    {\n      weather_jobs: \"Hourly\",\n      timeout_monitor: \"Every minute\",\n      memory_extraction: \"Every 30 minutes\"\n    }\n  end\n\n  def system_stats\n    {\n      rails_env: Rails.env,\n      uptime: Time.current - Rails.application.config.booted_at,\n      home_assistant: HomeAssistantService.available?,\n      llm_service: LlmService.available?\n    }\n  end\n\n  def recent_activity_feed\n    activities = []\n\n    # Recent conversations\n    Conversation.recent.limit(5).each do |conv|\n      activities << {\n        type: \"conversation\",\n        title: \"Conversation #{conv.session_id[0..8]}...\",\n        subtitle: \"#{conv.persona} - #{conv.active? ? 'Active' : 'Finished'}\",\n        timestamp: conv.updated_at,\n        path: admin_conversation_path(conv)\n      }\n    end\n\n    # Recent memories\n    ConversationMemory.recent.limit(3).each do |memory|\n      activities << {\n        type: \"memory\",\n        title: \"#{memory.memory_type.humanize} memory\",\n        subtitle: memory.summary.truncate(60),\n        timestamp: memory.created_at,\n        path: admin_memory_path(memory)\n      }\n    end\n\n    activities.sort_by { |a| a[:timestamp] }.reverse.first(10)\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/home_assistant_controller.rb`:\n\n```rb\n# app/controllers/home_assistant_controller.rb\nclass HomeAssistantController < ApplicationController\n  before_action :authenticate_home_assistant\n\n\n  # Health check endpoint for Home Assistant\n  def health\n    render json: {\n      status: \"ok\",\n      service: \"GlitchCube Voice Assistant\",\n      timestamp: Time.current.iso8601\n    }\n  end\n\n  # Get available entities endpoint (for context building)\n  def entities\n    entities = HomeAssistantService.entities.map do |entity|\n      {\n        entity_id: entity[\"entity_id\"],\n        name: entity.dig(\"attributes\", \"friendly_name\") || entity[\"entity_id\"],\n        domain: entity[\"entity_id\"].split(\".\").first,\n        state: entity[\"state\"]\n      }\n    end\n\n    render json: { entities: entities }\n  rescue StandardError => e\n    Rails.logger.error \"Error fetching entities: #{e.message}\"\n    render json: { error: \"Unable to fetch entities\" }, status: 500\n  end\n\n  # Generic trigger for any world state service\n  def trigger_world_state_service\n    service_class = params[:service_class]\n\n    return render json: { error: \"service_class required\" }, status: 400 if service_class.blank?\n\n    begin\n      klass = \"WorldStateUpdaters::#{service_class}\".constantize\n      klass.call\n      render json: { status: \"ok\" }\n    rescue NameError\n      render json: { error: \"invalid service\" }, status: 404\n    rescue StandardError => e\n      Rails.logger.error \"World state service error: #{e.message}\"\n      render json: { error: \"service failed\" }, status: 500\n    end\n  end\n\n  private\n\n  def authenticate_home_assistant\n    # Simple token-based authentication\n    token = request.headers[\"Authorization\"]&.gsub(\"Bearer \", \"\")\n\n    unless token == Rails.configuration.home_assistant_token\n      render json: { error: \"Unauthorized\" }, status: 401\n    end\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/api/v1/conversation_controller.rb`:\n\n```rb\n# app/controllers/api/v1/conversation_controller.rb\nclass Api::V1::ConversationController < Api::V1::BaseController\n  # This is the endpoint Home Assistant calls via /api/v1/conversation\n  def handle\n    # Extract message and context from HASS payload structure\n    message = extract_message_from_payload\n    context = extract_context_from_payload\n    session_id = extract_session_id_from_payload\n\n    Rails.logger.info \"üß† Processing HASS conversation: #{message}\"\n    Rails.logger.info \"üìã Session ID: #{session_id}\"\n    Rails.logger.info \"üîç Context: #{context}\"\n\n    result = ConversationOrchestrator.new(\n      session_id: session_id,\n      message: message,\n      context: context\n    ).call\n\n    # Format response in the structure HASS expects\n    formatted_response = format_response_for_hass(result)\n\n    Rails.logger.info \"üì§ Returning to HASS: #{formatted_response}\"\n    render json: formatted_response\n\n  rescue StandardError => e\n    Rails.logger.error \"ConversationController#process failed: #{e.message}\"\n    Rails.logger.error e.backtrace.join(\"\\n\")\n\n    # Return error in HASS-compatible format\n    render json: {\n      success: false,\n      error: e.message,\n      data: {\n        response_type: \"error\",\n        speech_text: \"I'm sorry, I encountered an error processing your request. Please try again.\",\n        error_details: e.message\n      }\n    }, status: 500\n  end\n\n  def proactive\n    # Extract simple trigger and context strings\n    trigger = params[:trigger] || \"unknown_trigger\"\n    context = params[:context] || \"no additional context provided\"\n\n    # Create a proactive message for the orchestrator\n    proactive_message = \"[PROACTIVE] #{trigger}: #{context}\"\n\n    Rails.logger.info \"ü§ñ Processing proactive conversation: #{proactive_message}\"\n\n    # Use a default session_id for proactive conversations\n    session_id = extract_session_id_from_payload || default_proactive_session_id\n\n    # Build context for proactive conversation\n    proactive_context = {\n      conversation_id: \"proactive_#{SecureRandom.hex(8)}\",\n      device_id: \"cube_proactive_system\",\n      language: \"en\",\n      voice_interaction: false,\n      timestamp: Time.current.iso8601,\n      source: \"proactive_trigger\",\n      trigger: trigger,\n      context: context\n    }\n\n    result = ConversationOrchestrator.new(\n      session_id: session_id,\n      message: proactive_message,\n      context: proactive_context\n    ).call\n\n    # Format response in the structure that HASS expects\n    formatted_response = format_response_for_hass(result)\n\n    Rails.logger.info \"ü§ñ Proactive response completed: #{trigger}\"\n    render json: formatted_response\n\n  rescue StandardError => e\n    Rails.logger.error \"ProactiveConversationController failed: #{e.message}\"\n    Rails.logger.error e.backtrace.join(\"\\n\")\n\n    # Return error in HASS-compatible format\n    render json: {\n      success: false,\n      error: e.message,\n      data: {\n        response_type: \"error\",\n        speech_text: \"I encountered an error processing the proactive trigger. Please check the system.\",\n        error_details: e.message\n      }\n    }, status: 500\n  end\n\n  def health\n    render json: {\n      status: \"ok\",\n      version: Rails.application.version || \"1.0.0\",\n      conversation_agent: \"cube_conversation\",\n      orchestrator: \"enabled\",\n      timestamp: Time.current.iso8601\n    }\n  end\n\n  private\n\n  def extract_message_from_payload\n    # HASS sends message in this structure (but be careful with proactive calls)\n    message = params[:message] || params[:text] || \"\"\n\n    # Only try to dig into context if it's a hash\n    if message.blank? && params[:context].is_a?(Hash)\n      message = params.dig(:context, :message) || \"\"\n    end\n\n    message\n  end\n\n  def extract_session_id_from_payload\n    # HASS sends session_id in context (but in proactive calls, context is a string)\n    session_id = if params[:context].is_a?(Hash)\n      params.dig(:context, :session_id)\n    else\n      params[:session_id]\n    end\n\n    session_id || default_session_id\n  end\n\n  def extract_context_from_payload\n    context = params[:context] || {}\n    ha_context = context[:ha_context] || {}\n\n    {\n      conversation_id: context[:conversation_id],\n      device_id: context[:device_id],\n      language: context[:language] || \"en\",\n      voice_interaction: context[:voice_interaction] || false,\n      timestamp: context[:timestamp],\n      ha_context: ha_context,\n      agent_id: ha_context[:agent_id],\n      source: \"hass_conversation\"\n    }\n  end\n\n  def format_response_for_hass(orchestrator_result)\n    # Format in the structure that HASS conversation agent expects\n    return error_response(\"Invalid orchestrator result\") unless orchestrator_result.is_a?(Hash)\n\n    response_data = orchestrator_result[:response] || {}\n    return error_response(\"Invalid response data\") unless response_data.is_a?(Hash)\n\n    speech_data = response_data[:speech] || {}\n    speech_text = if speech_data.is_a?(Hash)\n      speech_data.dig(:plain, :speech) || \"I understand.\"\n    else\n      \"I understand.\"\n    end\n\n    {\n      success: true,\n      data: {\n        response_type: determine_response_type(orchestrator_result),\n        response: speech_text,\n        speech_text: speech_text,\n        continue_conversation: orchestrator_result[:continue_conversation] || false,\n        # Include metadata for debugging\n        metadata: (speech_data.is_a?(Hash) ? speech_data.dig(:plain, :extra_data) : nil) || {}\n      }\n    }\n  end\n\n  def error_response(message)\n    {\n      success: false,\n      error: message,\n      data: {\n        response_type: \"error\",\n        speech_text: \"I encountered an error. Please try again.\",\n        error_details: message\n      }\n    }\n  end\n\n  def determine_response_type(orchestrator_result)\n    # Check if async tools were queued\n    return \"normal\" unless orchestrator_result.is_a?(Hash)\n    return \"normal\" unless orchestrator_result[:response].is_a?(Hash)\n\n    metadata = orchestrator_result.dig(:response, :speech, :plain, :extra_data) || {}\n    return \"normal\" unless metadata.is_a?(Hash)\n\n    async_tools = metadata[:async_tools_queued] || []\n\n    if async_tools.any?\n      \"immediate_speech_with_background_tools\"\n    else\n      \"normal\"\n    end\n  end\n\n  def default_session_id\n    @default_session_id ||= Digest::SHA256.hexdigest(\n      \"cube_installation_#{ENV.fetch('INSTALLATION_ID', 'default')}\"\n    )[0..16]\n  end\n\n  def default_proactive_session_id\n    @default_proactive_session_id ||= Digest::SHA256.hexdigest(\n      \"cube_proactive_#{ENV.fetch('INSTALLATION_ID', 'default')}\"\n    )[0..16]\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/api/v1/base_controller.rb`:\n\n```rb\n# app/controllers/api/v1/base_controller.rb\nclass Api::V1::BaseController < Api::BaseController\n  # Base controller for all V1 API endpoints\n  # Add V1-specific functionality here\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/api/v1/summaries_controller.rb`:\n\n```rb\n# app/controllers/api/v1/summaries_controller.rb\nclass Api::V1::SummariesController < Api::V1::BaseController\n  def recent\n    limit = params[:limit]&.to_i || 3\n    limit = [ limit, 10 ].min # Cap at 10\n\n    summaries = Summary.recent.limit(limit).map do |summary|\n      {\n        id: summary.id,\n        summary_type: summary.summary_type,\n        summary_text: summary.summary_text,\n        start_time: summary.start_time,\n        end_time: summary.end_time,\n        message_count: summary.message_count,\n        created_at: summary.created_at,\n        metadata: summary.metadata_json\n      }\n    end\n\n    render json: { summaries: summaries }\n  rescue StandardError => e\n    Rails.logger.error \"Failed to fetch recent summaries: #{e.message}\"\n    render json: { error: \"Failed to fetch summaries\", summaries: [] }, status: 500\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/api/v1/gps_controller.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Api::V1::GpsController < Api::V1::BaseController\n  def location\n    begin\n      # Get current location with full context\n      location_data = ::Services::Gps::GPSTrackingService.new.current_location\n\n      if location_data.nil?\n        render json: {\n          error: \"GPS tracking not available\",\n          message: \"No GPS data - no Home Assistant connection\",\n          timestamp: Time.now.utc.iso8601\n        }, status: :service_unavailable\n      else\n        render json: location_data\n      end\n    rescue StandardError => e\n      render json: {\n        error: \"GPS service error\",\n        message: e.message,\n        timestamp: Time.now.utc.iso8601\n      }, status: :internal_server_error\n    end\n  end\n\n  def coords\n    location = ::Services::Gps::GPSTrackingService.new.current_location\n    if location&.dig(:lat) && location[:lng]\n      render json: {\n        lat: location[:lat],\n        lng: location[:lng]\n      }\n    else\n      render json: { error: \"No GPS coordinates available\" }, status: :service_unavailable\n    end\n  rescue StandardError => e\n    render json: { error: \"GPS coords error\", details: e.message }, status: :internal_server_error\n  end\n\n  def proximity\n    begin\n      current_loc = ::Services::Gps::GPSTrackingService.new.current_location\n      if current_loc && current_loc[:lat] && current_loc[:lng]\n        proximity = ::Services::Gps::GPSTrackingService.new.proximity_data(current_loc[:lat], current_loc[:lng])\n        render json: proximity\n      else\n        render json: { landmarks: [], portos: [], map_mode: \"normal\", visual_effects: [] }\n      end\n    rescue StandardError => e\n      render json: {\n        landmarks: [],\n        portos: [],\n        map_mode: \"normal\",\n        visual_effects: [],\n        error: e.message\n      }\n    end\n  end\n\n  def home\n    home_coords = GlitchCube.home_camp_coordinates\n    render json: home_coords\n  end\n\n  def simulate_movement\n    begin\n      if GlitchCube.gps_spoofing_allowed?\n        ::Services::Gps::GPSTrackingService.new.simulate_movement!\n        render json: { success: true, message: \"Movement simulation updated\" }\n      else\n        render json: { error: \"Simulation mode not enabled\" }, status: :bad_request\n      end\n    rescue StandardError => e\n      render json: { error: \"Simulation failed\", details: e.message }, status: :internal_server_error\n    end\n  end\n\n  def history\n    begin\n      # Simple history endpoint - will generate over time\n      # For now return current location as single point\n      current_loc = ::Services::Gps::GPSTrackingService.new.current_location\n\n      if current_loc && current_loc[:lat] && current_loc[:lng]\n        history = [ {\n          lat: current_loc[:lat],\n          lng: current_loc[:lng],\n          timestamp: Time.now.iso8601,\n          address: current_loc[:address] || \"Unknown location\"\n        } ]\n        render json: { history: history, total_points: 1, mode: \"live\" }\n      else\n        render json: { history: [], total_points: 0, mode: \"unavailable\", message: \"GPS not available\" }\n      end\n    rescue StandardError => e\n      render json: { error: \"Unable to fetch GPS history\", history: [], total_points: 0 }\n    end\n  end\n\n  def cube_current_loc\n    response.headers[\"Access-Control-Allow-Origin\"] = \"*\"\n    response.headers[\"Access-Control-Allow-Methods\"] = \"GET\"\n    response.headers[\"Access-Control-Allow-Headers\"] = \"Content-Type\"\n\n    begin\n      # Get GPS coordinates\n      location = ::Services::Gps::GPSTrackingService.new.current_location\n      if location.nil? || !location[:lat] || !location[:lng]\n        render plain: \"GPS unavailable\", status: :service_unavailable\n        return\n      end\n\n      # Get zone and address info\n      context = ::Services::Gps::LocationContextService.full_context(location[:lat], location[:lng])\n\n      # Return simple text: address if in city, zone otherwise\n      if context[:zone] == :city && context[:address]\n        render plain: context[:address]\n      else\n        render plain: context[:zone].to_s.humanize\n      end\n    rescue StandardError => e\n      render json: {\n        error: \"GPS service error\",\n        message: e.message,\n        timestamp: Time.now.utc.iso8601\n      }, status: :internal_server_error\n    end\n  end\n\n  def landmarks\n    # Cache landmarks forever - they don't move\n    response.headers[\"Cache-Control\"] = \"public, max-age=31536000\" # 1 year\n    response.headers[\"Expires\"] = (Time.now + 31_536_000).httpdate\n\n    begin\n      # Load all landmarks from database (cacheable since they don't move)\n      landmarks = Landmark.active.order(:name).map do |landmark|\n        {\n          name: landmark.name,\n          lat: landmark.latitude.to_f,\n          lng: landmark.longitude.to_f,\n          type: landmark.landmark_type,\n          priority: case landmark.landmark_type\n                    when \"center\", \"sacred\" then 1 # Highest priority for Man, Temple\n                    when \"medical\", \"ranger\" then 2  # High priority for emergency services\n                    when \"service\", \"toilet\" then 3  # Medium priority for utilities\n                    when \"art\" then 4 # Lower priority for art\n                    else 5 # Lowest priority for other landmarks\n                    end,\n          description: landmark.description || landmark.name\n        }\n      end\n\n      render json: {\n        landmarks: landmarks,\n        count: landmarks.length,\n        source: \"Database (Burning Man Innovate GIS Data 2025)\",\n        cache_hint: \"forever\" # Landmarks don't move, safe to cache indefinitely\n      }\n    rescue StandardError => e\n      # Fallback to hardcoded landmarks if database unavailable\n      render json: {\n        landmarks: [],\n        count: 0,\n        source: \"Fallback (empty)\",\n        error: \"Database unavailable: #{e.message}\"\n      }\n    end\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/api/v1/gis_controller.rb`:\n\n```rb\n# frozen_string_literal: true\n\nclass Api::V1::GisController < Api::V1::BaseController\n      def streets\n        begin\n          streets = Street.active\n          features = []\n\n          streets.each do |street|\n            coordinates = street.coordinates\n            next if coordinates.empty?\n\n            features << {\n              type: \"Feature\",\n              geometry: {\n                type: \"LineString\",\n                coordinates: coordinates\n              },\n              properties: {\n                id: \"street-#{street.id}\",\n                name: street.name,\n                width: street.width || 3,\n                type: street.street_type,\n                feature_type: \"street\"\n              }\n            }\n          end\n\n          render json: {\n            type: \"FeatureCollection\",\n            features: features,\n            count: features.length,\n            source: \"database\"\n          }\n        rescue StandardError => e\n          Rails.logger.error \"Error loading streets: #{e.message}\"\n          render json: {\n            type: \"FeatureCollection\",\n            features: [],\n            error: \"Streets data unavailable: #{e.message}\"\n          }\n        end\n      end\n\n      def blocks\n        begin\n          # For now, return empty GeoJSON - will need to implement GisCacheService\n          render json: { type: \"FeatureCollection\", features: [], error: \"Blocks data not yet implemented\" }\n        rescue StandardError => e\n          render json: { type: \"FeatureCollection\", features: [], error: \"Blocks data unavailable\" }\n        end\n      end\n\n      def landmarks_nearby\n        lat = params[:lat]&.to_f\n        lng = params[:lng]&.to_f\n\n        if lat && lng\n          # Use location context service for consistency\n          context = Services::Gps::LocationContextService.full_context(lat, lng)\n          render json: {\n            landmarks: context[:landmarks] || [],\n            count: (context[:landmarks] || []).length,\n            center: { lat: lat, lng: lng },\n            source: \"location_context\"\n          }\n        else\n          render json: { error: \"Missing lat/lng parameters\" }, status: :bad_request\n        end\n      end\n\n      def initial\n        # Load trash fence and all landmarks except toilets\n        fence = Boundary.trash_fence\n        all_landmarks = Landmark.active.where.not(landmark_type: \"toilet\")\n        features = []\n\n        # Add trash fence\n        if fence\n          features << {\n            type: \"Feature\",\n            geometry: {\n              type: \"Polygon\",\n              coordinates: fence.coordinates\n            },\n            properties: {\n              id: \"boundary-#{fence.id}\",\n              name: fence.name,\n              feature_type: \"boundary\"\n            }\n          }\n        end\n\n        # Add all landmarks (except toilets)\n        all_landmarks.each do |landmark|\n          feature_type = case landmark.landmark_type\n          when \"center\", \"sacred\", \"gathering\" then \"major_landmark\"\n          else \"landmark\"\n          end\n          features << {\n            type: \"Feature\",\n            geometry: {\n              type: \"Point\",\n              coordinates: [ landmark.longitude.to_f, landmark.latitude.to_f ]\n            },\n            properties: {\n              id: \"landmark-#{landmark.id}\",\n              name: landmark.name,\n              feature_type: feature_type,\n              landmark_type: landmark.landmark_type\n            }\n          }\n        end\n\n        render json: {\n          type: \"FeatureCollection\",\n          features: features,\n          count: features.length,\n          source: \"initial_load\"\n        }\n      rescue StandardError => e\n        render json: {\n          type: \"FeatureCollection\",\n          features: [],\n          count: 0,\n          error: e.message\n        }\n      end\n\n      def trash_fence\n        begin\n          # For now, return empty GeoJSON - will need to implement GisCacheService\n          render json: { type: \"FeatureCollection\", features: [], error: \"Trash fence data not yet implemented\" }\n        rescue StandardError => e\n          render json: { type: \"FeatureCollection\", features: [], error: \"Trash fence data unavailable\" }\n        end\n      end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/api/base_controller.rb`:\n\n```rb\n# app/controllers/api/base_controller.rb\nclass Api::BaseController < ApplicationController\n  # Skip CSRF token verification for API endpoints\n  skip_before_action :verify_authenticity_token\n\n  # Base controller for all API endpoints\n  # Add common API functionality here\n\n  private\n\n  def render_api_error(message, status = :unprocessable_entity)\n    render json: { error: message }, status: status\n  end\n\n  def render_api_success(data, status = :ok)\n    render json: { success: true, data: data }, status: status\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/performance_controller.rb`:\n\n```rb\n# app/controllers/performance_controller.rb\n# Web interface for performance mode management\n\nclass PerformanceController < ApplicationController\n  def index\n    @session_id = params[:session_id] || \"web_performance_session\"\n    @active_performance = CubePerformance.performance_status(@session_id)\n  end\n\n  def start\n    session_id = params[:session_id] || \"web_performance_session\"\n    performance_type = params[:performance_type]\n    duration_minutes = params[:duration_minutes].to_i\n\n    begin\n      case performance_type\n      when \"standup_comedy\"\n        CubePerformance.standup_comedy(\n          duration_minutes: duration_minutes,\n          session_id: session_id\n        )\n      when \"adventure_story\"\n        CubePerformance.adventure_story(\n          duration_minutes: duration_minutes,\n          session_id: session_id\n        )\n      when \"improv\"\n        CubePerformance.improv_session(\n          duration_minutes: duration_minutes,\n          session_id: session_id\n        )\n      when \"poetry\"\n        CubePerformance.poetry_slam(\n          duration_minutes: duration_minutes,\n          session_id: session_id\n        )\n      else\n        flash[:error] = \"Unknown performance type: #{performance_type}\"\n        redirect_to performance_index_path(session_id: session_id) and return\n      end\n\n      flash[:success] = \"Started #{performance_type} performance for #{duration_minutes} minutes\"\n\n    rescue => e\n      flash[:error] = \"Failed to start performance: #{e.message}\"\n    end\n\n    redirect_to performance_index_path(session_id: session_id)\n  end\n\n  def stop\n    session_id = params[:session_id] || \"web_performance_session\"\n\n    begin\n      success = CubePerformance.stop_performance(session_id, reason: \"web_interface_stop\")\n\n      if success\n        flash[:success] = \"Performance stopped\"\n      else\n        flash[:warning] = \"No active performance to stop\"\n      end\n\n    rescue => e\n      flash[:error] = \"Failed to stop performance: #{e.message}\"\n    end\n\n    redirect_to performance_index_path(session_id: session_id)\n  end\n\n  def status\n    session_id = params[:session_id] || \"web_performance_session\"\n    status = CubePerformance.performance_status(session_id)\n\n    render json: status\n  end\nend\n\n```\n\n`/Users/estiens/code/glitchcube-main/glitchcube_rails/app/controllers/performance_mode_controller.rb`:\n\n```rb\n# app/controllers/performance_mode_controller.rb\n# API endpoints for controlling performance mode\n\nclass PerformanceModeController < ApplicationController\n  before_action :set_session_id\n\n  # POST /performance_mode/start\n  def start\n    performance_type = params[:performance_type] || \"comedy\"\n    duration_minutes = (params[:duration_minutes] || 10).to_i\n    prompt = params[:prompt]\n    persona = params[:persona]\n\n    Rails.logger.info \"üé≠ Starting #{performance_type} performance for #{duration_minutes} minutes\"\n\n    begin\n      # Check if there's already an active performance\n      existing_performance = PerformanceModeService.get_active_performance(@session_id)\n      if existing_performance&.is_running?\n        render json: {\n          error: \"Performance already running for this session\",\n          current_performance: {\n            type: existing_performance.performance_type,\n            time_remaining: existing_performance.time_remaining\n          }\n        }, status: 422\n        return\n      end\n\n      # Start new performance\n      service = PerformanceModeService.start_performance(\n        session_id: @session_id,\n        performance_type: performance_type,\n        duration_minutes: duration_minutes,\n        prompt: prompt,\n        persona: persona\n      )\n\n      render json: {\n        message: \"Performance mode started\",\n        session_id: @session_id,\n        performance_type: performance_type,\n        duration_minutes: duration_minutes,\n        estimated_end_time: (Time.current + duration_minutes.minutes).iso8601\n      }\n\n    rescue => e\n      Rails.logger.error \"‚ùå Failed to start performance mode: #{e.message}\"\n      render json: {\n        error: \"Failed to start performance mode\",\n        details: e.message\n      }, status: 500\n    end\n  end\n\n  # POST /performance_mode/stop\n  def stop\n    reason = params[:reason] || \"manual_stop\"\n\n    begin\n      success = PerformanceModeService.stop_active_performance(@session_id, reason)\n\n      if success\n        render json: {\n          message: \"Performance mode stopped\",\n          reason: reason,\n          session_id: @session_id\n        }\n      else\n        render json: {\n          message: \"No active performance to stop\",\n          session_id: @session_id\n        }, status: 404\n      end\n\n    rescue => e\n      Rails.logger.error \"‚ùå Failed to stop performance mode: #{e.message}\"\n      render json: {\n        error: \"Failed to stop performance mode\",\n        details: e.message\n      }, status: 500\n    end\n  end\n\n  # GET /performance_mode/status\n  def status\n    begin\n      service = PerformanceModeService.get_active_performance(@session_id)\n\n      if service && service.is_running?\n        render json: {\n          active: true,\n          session_id: @session_id,\n          performance_type: service.performance_type,\n          time_remaining_seconds: service.time_remaining,\n          time_remaining_minutes: (service.time_remaining / 60.0).round(1),\n          duration_minutes: service.duration_minutes,\n          start_time: service.instance_variable_get(:@start_time)&.iso8601,\n          estimated_end_time: service.instance_variable_get(:@end_time)&.iso8601\n        }\n      else\n        render json: {\n          active: false,\n          session_id: @session_id,\n          message: \"No active performance\"\n        }\n      end\n\n    rescue => e\n      Rails.logger.error \"‚ùå Failed to get performance status: #{e.message}\"\n      render json: {\n        error: \"Failed to get performance status\",\n        details: e.message\n      }, status: 500\n    end\n  end\n\n  # POST /performance_mode/interrupt\n  # Called when wake word is detected during performance\n  def interrupt\n    begin\n      service = PerformanceModeService.get_active_performance(@session_id)\n\n      if service && service.is_running?\n        service.interrupt_for_wake_word\n\n        render json: {\n          message: \"Performance interrupted for wake word\",\n          session_id: @session_id\n        }\n      else\n        render json: {\n          message: \"No active performance to interrupt\",\n          session_id: @session_id\n        }, status: 404\n      end\n\n    rescue => e\n      Rails.logger.error \"‚ùå Failed to interrupt performance: #{e.message}\"\n      render json: {\n        error: \"Failed to interrupt performance\",\n        details: e.message\n      }, status: 500\n    end\n  end\n\n  private\n\n  def set_session_id\n    @session_id = params[:session_id] || request.headers[\"X-Session-ID\"] || \"default_performance_session\"\n  end\nend\n\n```",
  "token_count": 0
}
